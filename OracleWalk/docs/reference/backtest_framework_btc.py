# -*- coding: utf-8 -*-
"""Backtest_Framework_BTC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hzE7C4zARR8UPouyXgKHJ4jLGQGiNjVz

# üß™ Backtest Framework ‚Äî Colab Mini-MT5 (v1)
**Gerado:** 2025-11-12 22:53:17  
**Objetivo:** ambiente gen√©rico de backtest onde o trader s√≥ escreve a **estrat√©gia** e o framework faz o resto (dados ‚Üí execu√ß√£o ‚Üí m√©tricas ‚Üí plots ‚Üí relat√≥rio).

> **Como usar:** Siga os blocos de cima para baixo. No bloco **06_ESTRATEGIA**, escreva/cole sua fun√ß√£o `generate_signals(df)`.

## 01 ‚Äî Instala√ß√£o & Imports
"""

# Se estiver no Colab, tudo abaixo j√° existe. Descomente se precisar instalar algo extra.
!pip -q install pandas numpy matplotlib ta
!pip install mplcyberpunk

import os, re, math, uuid, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
warnings.filterwarnings('ignore')

pd.set_option('display.max_colwidth', 120)
print('‚úÖ Imports prontos.')

"""## 02 ‚Äî Configura√ß√µes Gerais"""

CONFIG = {
    'fee_pct'     : 0.0004,   # 0.04% por opera√ß√£o (ida e volta ~0.08%)
    'commission_perc'    : 0.0004,   # 0.04% por execu√ß√£o
    'slippage_pct': 0.0001,   # 0.01% de slippage por execu√ß√£o
    'initial_cap' : 1000.0,   # capital inicial
    'risk_per_trade_pct': 1.0, # % do capital por trade (para sizing por SL)
    'allow_short' : True,     # cripto spot: normalmente False. Em futuros, True.
    'max_positions': 1,        # 1 posi√ß√£o por vez
    'price_col'   : 'close',   # pre√ßo usado para execu√ß√µes
}

print(CONFIG)

# ======================================================
#  BINANCE HTTP LOADER ‚Äì VERS√ÉO FINAL UNIFICADA
# ======================================================
import pandas as pd
import requests, zipfile, io
from datetime import datetime, timedelta

# ======================================================
# 1. Normaliza√ß√£o do TF (corrige 1H ‚Üí 1h etc)
# ======================================================
def normalize_tf(tf):
    tf = tf.strip().lower()
    fix = {
        "1h": "1h", "h1": "1h",
        "4h": "4h", "h4": "4h",
        "1d": "1d", "d1": "1d",
        "1m": "1m", "5m": "5m", "15m": "15m", "30m": "30m",
    }
    return fix.get(tf, tf)

# ======================================================
# 2. Downloader (arquivo ZIP mensal correto)
# ======================================================
def download_binance_month(symbol, timeframe, year, month):

    file_name = f"{symbol}-{timeframe}-{year}-{month:02d}.zip"
    url = (
        f"https://data.binance.vision/data/spot/monthly/klines/"
        f"{symbol}/{timeframe}/{file_name}"
    )

    r = requests.get(url)
    if r.status_code != 200:
        print(f"[x] N√£o existe: {url}")
        return None

    print(f"[OK] Baixado: {url}")

    z = zipfile.ZipFile(io.BytesIO(r.content))
    csv_name = z.namelist()[0]
    df = pd.read_csv(z.open(csv_name), header=None)

    df.columns = [
        "open_time", "open", "high", "low", "close", "volume",
        "close_time", "quote_volume", "trades",
        "taker_buy_base", "taker_buy_quote", "ignore"
    ]

    # FILTRO anti timestamp absurdo (bug da Binance)
    df = df[(df["open_time"] > 0) & (df["open_time"] < 32503680000000)]

    df["datetime"] = pd.to_datetime(df["open_time"], unit="ms")

    return df[["datetime","open","high","low","close","volume"]]

# ======================================================
# 3. VALIDATE_DATA (existia antes, agora est√° AQUI)
# ======================================================
def validate_data(df, timeframe):
    print("\n============================")
    print("üîç VALIDANDO CONSIST√äNCIA...")
    print("============================")

    df = df.sort_values("datetime").reset_index(drop=True)

    tf_map = {
        "1m": 1, "5m": 5, "15m": 15, "30m": 30,
        "1h": 60, "4h": 240, "1d": 1440
    }

    size = tf_map.get(timeframe.lower(), 60)
    expected = timedelta(minutes=size)

    df["next"] = df["datetime"].shift(-1)
    df["diff"] = df["next"] - df["datetime"]

    gaps = df[df["diff"] > expected]
    dups = df[df["datetime"].duplicated()]

    print(f"Total candles: {len(df)}")
    print(f"Gaps detectados: {len(gaps)}")
    print(f"Duplicados removidos: {len(dups)}")

    df = df.drop_duplicates(subset="datetime")
    df = df.drop(columns=["next","diff"], errors="ignore")

    return df

# ======================================================
# 4. Loader Principal
# ======================================================
def fetch_binance_http():
    print("=== BINANCE HTTP LOADER FINAL ===")

    symbol = input("Ativo (ex: BTCUSDT): ").strip().upper()
    timeframe = normalize_tf(input("TF (1m,5m,15m,30m,1h,4h,1d): ").strip())

    print("\nPer√≠odo:")
    print("1 ‚Üí 1 m√™s")
    print("2 ‚Üí 3 meses")
    print("3 ‚Üí 6 meses")
    print("4 ‚Üí 1 ano")
    print("5 ‚Üí 2 anos")
    print("6 ‚Üí 3 anos")
    print("7 ‚Üí 5 anos")
    print("8 ‚Üí TUDO (2017‚Üíhoje)")
    choice = int(input("Escolha: "))

    REAL_BINANCE_MAX = datetime(2025, 10, 31)
    now = min(datetime.utcnow(), REAL_BINANCE_MAX)

    periods = {
        1: now - timedelta(days=30),
        2: now - timedelta(days=90),
        3: now - timedelta(days=180),
        4: now - timedelta(days=365),
        5: now - timedelta(days=365*2),
        6: now - timedelta(days=365*3),
        7: now - timedelta(days=365*5),
        8: datetime(2017,1,1)
    }

    start = periods.get(choice, now - timedelta(days=30))

    print(f"[INFO] Baixando {symbol} {timeframe} de {start.date()} at√© {now.date()}...\n")

    dfs = []
    year = start.year
    month = start.month

    while (year < now.year) or (year == now.year and month <= now.month):

        if year == now.year and month == now.month:
            break

        print(f"Baixando {year}-{month:02d}...")
        dfm = download_binance_month(symbol, timeframe, year, month)

        if dfm is not None:
            dfs.append(dfm)

        month += 1
        if month == 13:
            month = 1
            year += 1

    if not dfs:
        print("[ERRO] Nenhum arquivo encontrado.")
        return None

    full = pd.concat(dfs).sort_values("datetime").reset_index(drop=True)
    print(f"[OK] Candles brutos: {len(full)}")

    clean = validate_data(full, timeframe)
    print(f"[FINAL] Candles limpos: {len(clean)}")

    return clean


# ===================== USO =====================
df_raw = fetch_binance_http()
df_raw.head()

# ========================================================
#  CONSISTENCY VALIDATOR PRO ‚Äì Estilo Tick Data Suite
# ========================================================
import pandas as pd
import numpy as np

class DataQualitySuite:
    def __init__(self, df: pd.DataFrame, timeframe: str):
        self.df = df.copy()
        self.timeframe = timeframe.lower()
        self.issues = {
            "timestamp_gaps": [],
            "timestamp_duplicates": [],
            "timestamp_out_of_order": [],
            "invalid_candles": [],
            "price_anomalies": [],
            "volume_anomalies": [],
        }

    # -----------------------------------------
    # 1. Calcula o delta esperado entre candles
    # -----------------------------------------
    def _expected_delta(self):
        tf_map = {
            "1m": 1,
            "5m": 5,
            "15m": 15,
            "30m": 30,
            "1h": 60,
            "2h": 120,
            "4h": 240,
            "1d": 1440,
        }
        minutes = tf_map.get(self.timeframe, 60)
        return pd.Timedelta(minutes=minutes)

    # -----------------------------------------
    # 2. Verificar integridade de timestamps
    # -----------------------------------------
    def check_timestamps(self):
        df = self.df.sort_values("datetime").reset_index(drop=True)
        exp = self._expected_delta()

        for i in range(len(df) - 1):
            t1 = df.loc[i, "datetime"]
            t2 = df.loc[i + 1, "datetime"]

            delta = t2 - t1

            # gap
            if delta > exp:
                self.issues["timestamp_gaps"].append((i, t1, t2, delta))

            # fora de ordem
            if delta.total_seconds() < 0:
                self.issues["timestamp_out_of_order"].append((i, t1, t2))

        # duplicados
        dups = df[df["datetime"].duplicated()]["datetime"].tolist()
        self.issues["timestamp_duplicates"] = dups

    # -----------------------------------------
    # 3. Valida√ß√£o interna do candle
    # -----------------------------------------
    def check_candle_integrity(self):
        df = self.df

        for i, row in df.iterrows():
            o, h, l, c = float(row.open), float(row.high), float(row.low), float(row.close)

            # regras essenciais
            if not (l <= o <= h and l <= c <= h):
                self.issues["invalid_candles"].append((i, row.datetime))

            # valores negativos ou absurdos
            if o <= 0 or h <= 0 or l <= 0 or c <= 0:
                self.issues["invalid_candles"].append((i, row.datetime))

            # high < low?
            if h < l:
                self.issues["invalid_candles"].append((i, row.datetime))

    # -----------------------------------------
    # 4. Anomalias de pre√ßo (spikes)
    # -----------------------------------------
    def check_price_anomalies(self):
        df = self.df.sort_values("datetime").reset_index(drop=True)

        # varia√ß√£o do candle
        df["range_pct"] = (df["high"] - df["low"]) / df["open"].replace(0, np.nan)

        # spikes absurdos (ex: >20%)
        anomalies = df[df["range_pct"] > 0.20]

        for idx, row in anomalies.iterrows():
            self.issues["price_anomalies"].append(
                (idx, row.datetime, float(row.range_pct))
            )

    # -----------------------------------------
    # 5. Anomalias de volume
    # -----------------------------------------
    def check_volume(self):
        df = self.df

        # volume zero em timeframes > 1m √© estranho
        vol_zero = df[df["volume"] == 0]

        for idx, row in vol_zero.iterrows():
            self.issues["volume_anomalies"].append((idx, row.datetime))

        # volume absurdamente alto
        threshold = df["volume"].mean() + 5 * df["volume"].std()
        vol_spikes = df[df["volume"] > threshold]

        for idx, row in vol_spikes.iterrows():
            self.issues["volume_anomalies"].append((idx, row.datetime))

    # -----------------------------------------
    # 6. Rodar tudo
    # -----------------------------------------
    def run(self):
        print("üîç Executando valida√ß√£o completa...\n")

        self.check_timestamps()
        self.check_candle_integrity()
        self.check_price_anomalies()
        self.check_volume()

        print("‚úî Valida√ß√£o conclu√≠da.\n")

    # -----------------------------------------
    # 7. Score final (0‚Äì100)
    # -----------------------------------------
    def score(self):
        base = 100

        penalties = (
            len(self.issues["timestamp_gaps"]) * 2 +
            len(self.issues["timestamp_duplicates"]) * 2 +
            len(self.issues["timestamp_out_of_order"]) * 3 +
            len(self.issues["invalid_candles"]) * 4 +
            len(self.issues["price_anomalies"]) * 1 +
            len(self.issues["volume_anomalies"]) * 1
        )

        return max(0, base - penalties)

    # -----------------------------------------
    # 8. Relat√≥rio completo
    # -----------------------------------------
    def report(self):
        print("=====================================")
        print("üìä RELAT√ìRIO FINAL DE CONSIST√äNCIA")
        print("=====================================\n")

        for issue_type, items in self.issues.items():
            print(f"{issue_type}: {len(items)}")

        print("\n-------------------------------------")
        print(f"‚≠ê SCORE FINAL DA QUALIDADE: {self.score()}/100")
        print("-------------------------------------")

        if self.score() >= 95:
            print("‚úî Qualidade EXCELENTE")
        elif self.score() >= 85:
            print("‚úî Qualidade MUITO BOA")
        elif self.score() >= 70:
            print("‚ö† Qualidade RAZO√ÅVEL")
        else:
            print("‚ùå Qualidade RUIM ‚Äî precisa corrigir\n")

validator = DataQualitySuite(df_raw, timeframe="1h")
validator.run()
validator.report()

# =========================================================
#   INDICATORS PACK ‚Äî "MT5 Style"
#   Fun√ß√µes de indicadores que recebem df e devolvem df
# =========================================================

import numpy as np
import pandas as pd

# -------------------------------------------
# Helpers
# -------------------------------------------
def _ensure_datetime_index(df):
    df = df.copy()
    if "datetime" in df.columns:
        df["datetime"] = pd.to_datetime(df["datetime"])
    return df

# -------------------------------------------
# SMA ‚Äî Simple Moving Average
# -------------------------------------------
def add_sma(df, period=20, col="close", name=None):
    df = df.copy()
    if name is None:
        name = f"sma{period}"
    df[name] = df[col].rolling(period).mean()
    return df

# -------------------------------------------
# EMA ‚Äî Exponential Moving Average
# -------------------------------------------
def add_ema(df, period=20, col="close", name=None):
    df = df.copy()
    if name is None:
        name = f"ema{period}"
    df[name] = df[col].ewm(span=period, adjust=False).mean()
    return df

# -------------------------------------------
# RSI ‚Äî Relative Strength Index
# -------------------------------------------
def add_rsi(df, period=14, col="close", name="rsi"):
    df = df.copy()
    delta = df[col].diff()

    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)

    avg_gain = gain.rolling(period).mean()
    avg_loss = loss.rolling(period).mean()

    rs = avg_gain / avg_loss
    df[name] = 100 - (100 / (1 + rs))
    return df

# -------------------------------------------
# ATR ‚Äî Average True Range
# -------------------------------------------
def add_atr(df, period=14, name="atr"):
    df = df.copy()
    high = df["high"]
    low  = df["low"]
    close_prev = df["close"].shift(1)

    tr1 = high - low
    tr2 = (high - close_prev).abs()
    tr3 = (low  - close_prev).abs()

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    df["tr"] = tr
    df[name] = tr.rolling(period).mean()
    return df

# -------------------------------------------
# ADX ‚Äî Average Directional Index
# -------------------------------------------
def add_adx(df, period=14, name="adx"):
    df = df.copy()
    high = df["high"]
    low  = df["low"]
    close_prev = df["close"].shift(1)

    # True Range
    tr1 = high - low
    tr2 = (high - close_prev).abs()
    tr3 = (low  - close_prev).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    # +DM / -DM
    plus_dm  = (high - high.shift(1)).where( (high - high.shift(1)) > (low.shift(1) - low), 0.0 )
    plus_dm  = plus_dm.where(plus_dm > 0, 0.0)

    minus_dm = (low.shift(1) - low).where( (low.shift(1) - low) > (high - high.shift(1)), 0.0 )
    minus_dm = minus_dm.where(minus_dm > 0, 0.0)

    tr_n     = tr.rolling(period).sum()
    plus_di  = 100 * (plus_dm.rolling(period).sum()  / tr_n)
    minus_di = 100 * (minus_dm.rolling(period).sum() / tr_n)

    dx = ( (plus_di - minus_di).abs() / (plus_di + minus_di).replace(0, np.nan) ) * 100
    adx = dx.rolling(period).mean()

    df["plus_di"]  = plus_di
    df["minus_di"] = minus_di
    df[name] = adx
    return df

# -------------------------------------------
# MACD ‚Äî Moving Average Convergence Divergence
# -------------------------------------------
def add_macd(df, fast=12, slow=26, signal=9,
             col="close",
             name_macd="macd",
             name_signal="macd_signal",
             name_hist="macd_hist"):
    df = df.copy()
    ema_fast = df[col].ewm(span=fast, adjust=False).mean()
    ema_slow = df[col].ewm(span=slow, adjust=False).mean()

    macd = ema_fast - ema_slow
    macd_signal = macd.ewm(span=signal, adjust=False).mean()
    macd_hist = macd - macd_signal

    df[name_macd]   = macd
    df[name_signal] = macd_signal
    df[name_hist]   = macd_hist
    return df

# -------------------------------------------
# Bollinger Bands
# -------------------------------------------
def add_bbands(df, period=20, std_mult=2,
               col="close",
               name_mid="bb_mid",
               name_up="bb_up",
               name_low="bb_low"):
    df = df.copy()
    ma = df[col].rolling(period).mean()
    std = df[col].rolling(period).std()

    df[name_mid] = ma
    df[name_up]  = ma + std_mult * std
    df[name_low] = ma - std_mult * std
    return df

# -------------------------------------------
# Stochastic Oscillator (%K, %D)
# -------------------------------------------
def add_stochastic(df, k_period=14, d_period=3,
                   name_k="stoch_k",
                   name_d="stoch_d"):
    df = df.copy()
    low_min  = df["low"].rolling(k_period).min()
    high_max = df["high"].rolling(k_period).max()

    stoch_k = 100 * (df["close"] - low_min) / (high_max - low_min)
    stoch_d = stoch_k.rolling(d_period).mean()

    df[name_k] = stoch_k
    df[name_d] = stoch_d
    return df

# -------------------------------------------
# VWAP ‚Äî Volume Weighted Average Price
# -------------------------------------------
def add_vwap(df, name="vwap"):
    df = df.copy()
    typical_price = (df["high"] + df["low"] + df["close"]) / 3
    cum_tp_vol = (typical_price * df["volume"]).cumsum()
    cum_vol = df["volume"].cumsum()
    df[name] = cum_tp_vol / cum_vol.replace(0, np.nan)
    return df

# -------------------------------------------
# SuperTrend (simplificado)
# -------------------------------------------
def add_supertrend(df, period=10, multiplier=3, name="supertrend"):
    """
    SuperTrend simples baseado em ATR.
    Marca linha de tend√™ncia; valores >0 podem representar tend√™ncia de alta.
    """
    df = add_atr(df, period=period)  # garante coluna 'atr'
    df = df.copy()

    hl2 = (df["high"] + df["low"]) / 2
    basic_ub = hl2 + multiplier * df["atr"]
    basic_lb = hl2 - multiplier * df["atr"]

    final_ub = basic_ub.copy()
    final_lb = basic_lb.copy()

    for i in range(1, len(df)):
        if (final_ub.iloc[i] > final_ub.iloc[i-1]) or (df["close"].iloc[i-1] > final_ub.iloc[i]):
            final_ub.iloc[i] = final_ub.iloc[i-1]
        if (final_lb.iloc[i] < final_lb.iloc[i-1]) or (df["close"].iloc[i-1] < final_lb.iloc[i]):
            final_lb.iloc[i] = final_lb.iloc[i-1]

    supertrend = pd.Series(index=df.index, dtype=float)
    for i in range(len(df)):
        if i == 0:
            supertrend.iloc[i] = final_ub.iloc[i]
        else:
            if (supertrend.iloc[i-1] == final_ub.iloc[i-1]) and (df["close"].iloc[i] <= final_ub.iloc[i]):
                supertrend.iloc[i] = final_ub.iloc[i]
            elif (supertrend.iloc[i-1] == final_ub.iloc[i-1]) and (df["close"].iloc[i] > final_ub.iloc[i]):
                supertrend.iloc[i] = final_lb.iloc[i]
            elif (supertrend.iloc[i-1] == final_lb.iloc[i-1]) and (df["close"].iloc[i] >= final_lb.iloc[i]):
                supertrend.iloc[i] = final_lb.iloc[i]
            elif (supertrend.iloc[i-1] == final_lb.iloc[i-1]) and (df["close"].iloc[i] < final_lb.iloc[i]):
                supertrend.iloc[i] = final_ub.iloc[i]

    df[name] = supertrend
    return df

# -------------------------------------------
# FAIR VALUE GAP INDICATOR
# -------------------------------------------

def detect_fvg(
    df: pd.DataFrame,
    extend_bars: int = 50,      # mantido s√≥ pra compatibilidade com o resto do c√≥digo
    lookback: int = 2000,       # mesmo "loockback" do Pine
    filter_percent: float = 0.5 # mesmo "Filter Gaps by %" do Pine
) -> pd.DataFrame:
    """
    Detec√ß√£o de Fair Value Gaps no estilo BigBeluga (Pine Script).

    Retorna DataFrame com:
    - index  : √≠ndice do candle que gerou o FVG (equivalente ao bar_index no Pine)
    - type   : 'bullish' ou 'bearish'
    - top    : topo do gap
    - bottom : fundo do gap
    - mid    : n√≠vel de 50% do gap
    - gap_pct: tamanho do gap em %
    """

    highs = df["high"].to_numpy()
    lows  = df["low"].to_numpy()
    n     = len(df)

    if n < 3:
        return pd.DataFrame(columns=["index", "type", "top", "bottom", "mid", "gap_pct"])

    # √≠ndice inicial pra respeitar o lookback (√∫ltimos N candles)
    start_i = 2

    rows = []

    for i in range(start_i, n):
        # candles usados:
        # i-2 = candle "C0"
        # i-1 = candle "C1"
        # i   = candle atual "C2" (onde o gap √© confirmado)
        h0 = highs[i-2]
        h1 = highs[i-1]
        h2 = highs[i]
        l0 = lows[i-2]
        l1 = lows[i-1]
        l2 = lows[i]

        # ---------------- BULLISH FVG (imbalance up) ----------------
        # Pine:
        # filt_up = (low - high[2]) / low * 100
        # isBull_gap = high[2] < low and high[2] < high[1] and low[2] < low and filt_up > filter
        if l2 != 0:
            filt_up = (l2 - h0) / l2 * 100.0
        else:
            filt_up = 0.0

        is_bull_gap = (
            h0 < l2 and          # high[2] < low
            h0 < h1 and          # high[2] < high[1]
            l0 < l2 and          # low[2] < low
            filt_up > filter_percent
        )

        if is_bull_gap:
            top    = float(l2)   # topo do gap
            bottom = float(h0)   # fundo do gap
            mid    = (top + bottom) / 2.0
            rows.append({
                "index":  i,
                "type":   "bullish",
                "top":    top,
                "bottom": bottom,
                "mid":    mid,
                "gap_pct": float(filt_up),
            })

        # ---------------- BEARISH FVG (imbalance down) ----------------
        # Pine:
        # filt_dn   = (low[2] - high) / low[2] * 100
        # isBear_gap = low[2] > high and low[2] > low[1] and high[2] > high and filt_dn > filter
        if l0 != 0:
            filt_dn = (l0 - h2) / l0 * 100.0
        else:
            filt_dn = 0.0

        is_bear_gap = (
            l0 > h2 and          # low[2] > high
            l0 > l1 and          # low[2] > low[1]
            h0 > h2 and          # high[2] > high
            filt_dn > filter_percent
        )

        if is_bear_gap:
            top    = float(l0)   # topo do gap
            bottom = float(h2)   # fundo do gap
            mid    = (top + bottom) / 2.0
            rows.append({
                "index":  i,
                "type":   "bearish",
                "top":    top,
                "bottom": bottom,
                "mid":    mid,
                "gap_pct": float(filt_dn),
            })

    fvg_df = pd.DataFrame(rows, columns=["index", "type", "top", "bottom", "mid", "gap_pct"])
    return fvg_df

# ------------------------------------
# 2. VOLUME FINANCEIRO
# ------------------------------------
def volume_indicator(df: pd.DataFrame, length=20, spike_multiplier=1.5):
    """
    Volume simples para o framework.
    - volume m√©dio
    - volume spike
    - volume acima/abaixo da m√©dia
    - cor do candle pelo volume

    df precisa conter colunas: ["open", "high", "low", "close", "volume"]
    """

    # Volume normal
    df["vol"] = df["volume"]

    # M√©dia de volume
    df["vol_ma"] = df["volume"].rolling(length).mean()

    # Volume spike (cuando o volume est√° muito acima da m√©dia)
    df["vol_spike"] = df["vol"] > (df["vol_ma"] * spike_multiplier)

    # Volume acima/abaixo da m√©dia
    df["vol_high"] = df["vol"] > df["vol_ma"]
    df["vol_low"] = df["vol"] < df["vol_ma"]

    # Cor do candle por volume
    df["vol_color"] = df.apply(
        lambda row: "green" if row["close"] > row["open"] else "red",
        axis=1
    )

    return df

# ------------------------------------
# 2. ORDERBLOCK
# ------------------------------------

def detect_orderblocks(df: pd.DataFrame, lookback=5, extend_bars=50):
    """
    Detecta Order Blocks ICT reais:
    - OB de compra = √∫ltimo candle de baixa antes do BOS de alta
    - OB de venda = √∫ltimo candle de alta antes do BOS de baixa
    - Verifica ruptura real dos swings
    - Exporta coordenadas para desenho (ret√¢ngulos)
    """

    orderblocks = []

    # 1 ‚Äî Criar colunas auxiliares de swing high/low
    df["swing_high"] = df["high"].rolling(lookback).max()
    df["swing_low"] = df["low"].rolling(lookback).min()

    for i in range(lookback, len(df)):

        curr_close = df["close"].iloc[i]

        prev_swing_high = df["swing_high"].iloc[i-1]
        prev_swing_low  = df["swing_low"].iloc[i-1]

        # ===========================
        # BOS DE ALTA ‚Üí OB BULLISH
        # ===========================
        if curr_close > prev_swing_high:

            # procurar o √∫ltimo candle bearish antes do BOS
            for j in range(i-1, i-1-lookback, -1):
                if df["close"].iloc[j] < df["open"].iloc[j]:  # candle vermelho
                    ob_open = df["open"].iloc[j]
                    ob_close = df["close"].iloc[j]
                    ob_high = df["high"].iloc[j]
                    ob_low = df["low"].iloc[j]

                    ob_top = max(ob_open, ob_close)
                    ob_bottom = min(ob_open, ob_close)
                    ob_mid = (ob_top + ob_bottom) / 2

                    orderblocks.append({
                        "index": j,
                        "type": "bullish",
                        "top": float(ob_top),
                        "bottom": float(ob_bottom),
                        "mid": float(ob_mid),
                        "project_right": extend_bars,
                        "color": "green"
                    })

                    break  # s√≥ o √∫ltimo v√°lido

        # ===========================
        # BOS DE BAIXA ‚Üí OB BEARISH
        # ===========================
        if curr_close < prev_swing_low:

            # procurar o √∫ltimo candle bullish antes do BOS
            for j in range(i-1, i-1-lookback, -1):
                if df["close"].iloc[j] > df["open"].iloc[j]:  # candle verde
                    ob_open = df["open"].iloc[j]
                    ob_close = df["close"].iloc[j]
                    ob_high = df["high"].iloc[j]
                    ob_low = df["low"].iloc[j]

                    ob_top = max(ob_open, ob_close)
                    ob_bottom = min(ob_open, ob_close)
                    ob_mid = (ob_top + ob_bottom) / 2

                    orderblocks.append({
                        "index": j,
                        "type": "bearish",
                        "top": float(ob_top),
                        "bottom": float(ob_bottom),
                        "mid": float(ob_mid),
                        "project_right": extend_bars,
                        "color": "red"
                    })

                    break

    return pd.DataFrame(orderblocks)

# -------------------------------------------
# PACOTE B√ÅSICO (igual "EA simples" chamando indicadores)
# -------------------------------------------
def add_basic_indicators(df):
    """
    Adiciona um conjunto padr√£o de indicadores:
    - ema9, ema21
    - rsi14
    - atr14
    - macd(12,26,9)
    - bollinger 20/2
    """
    df = _ensure_datetime_index(df)
    df = add_ema(df, 9,  name="ema9")
    df = add_ema(df, 21, name="ema21")
    df = add_rsi(df, 14, name="rsi14")
    df = add_atr(df, 14, name="atr14")
    df = add_macd(df)  # nomes padr√£o: macd, macd_signal, macd_hist
    df = add_bbands(df, 20, 2)
    return df

df_raw = add_atr(df_raw)

# ======================================================
# APLICAR INDICADORES PADR√ÉO NO DF PRINCIPAL
# ======================================================
df_raw = add_basic_indicators(df_raw)
df = df_raw.copy()
print("‚úÖ Indicadores adicionados ao df/df_raw:",
      [c for c in df.columns if c.startswith(("ema", "rsi", "atr", "macd", "bb_"))])


print("=== TESTE FVG ===")
fvg_test = detect_fvg(df_raw)
print(fvg_test.head())
print(fvg_test.columns)
print("Quantidade:", len(fvg_test))
print(df_raw.columns)

"""## 04 ‚Äî Utilit√°rios: Drawdown & M√©tricas"""

def equity_curve(pnl_series: pd.Series, initial_cap: float) -> pd.Series:
    return initial_cap + pnl_series.cumsum()

def compute_drawdown(equity: pd.Series) -> pd.DataFrame:
    roll_max = equity.cummax()
    dd = equity / roll_max - 1.0
    return pd.DataFrame({'equity': equity, 'roll_max': roll_max, 'drawdown': dd})

def performance_summary(trades: pd.DataFrame, initial_cap: float) -> dict:
    if trades.empty:
        return {
            'initial_capital': initial_cap,
            'final_balance'  : initial_cap,
            'net_profit'     : 0.0, 'trades': 0,
            'wins': 0, 'losses': 0, 'win_rate_pct': 0.0,
            'gross_profit'   : 0.0, 'gross_loss': 0.0,
            'profit_factor'  : 0.0, 'max_drawdown_pct': 0.0
        }
    final_balance = initial_cap + trades['pnl'].sum()
    wins = (trades['pnl'] > 0).sum()
    losses = (trades['pnl'] <= 0).sum()
    gross_profit = trades.loc[trades['pnl'] > 0, 'pnl'].sum()
    gross_loss   = trades.loc[trades['pnl'] <= 0, 'pnl'].sum()
    win_rate = 100.0 * wins / max(1, len(trades))
    profit_factor = (gross_profit / abs(gross_loss)) if gross_loss < 0 else np.inf

    eq = equity_curve(trades['pnl'], initial_cap)
    dd_df = compute_drawdown(eq)
    max_dd = dd_df['drawdown'].min() * 100.0

    return {
        'initial_capital': round(initial_cap, 2),
        'final_balance'  : round(final_balance, 2),
        'net_profit'     : round(final_balance - initial_cap, 2),
        'trades'         : int(len(trades)),
        'wins'           : int(wins),
        'losses'         : int(losses),
        'win_rate_pct'   : round(win_rate, 2),
        'gross_profit'   : round(gross_profit, 2),
        'gross_loss'     : round(gross_loss, 2),
        'profit_factor'  : round(profit_factor, 2) if np.isfinite(profit_factor) else np.inf,
        'max_drawdown_pct': round(max_dd, 2),
    }

print('‚úÖ Utils prontos.')

"""## 06 ‚Äî **Estrat√©gia** (voc√™ edita aqui)
Escreva sua fun√ß√£o `generate_signals(df)` abaixo.
"""

def generate_signals(df: pd.DataFrame):
    df = df.copy()
    df["datetime"] = pd.to_datetime(df["datetime"])

    # --- EMA 50 para filtro de tend√™ncia ---
    df["ema50"] = df["close"].ewm(span=50, adjust=False).mean()
    indicadores_usados = ["ema50"]

    # 1) Detecta FVGs com o indicador oficial
    fvg_df = detect_fvg(df, extend_bars=50)
    print("FVGs detectados (total):", len(fvg_df))

    # DataFrame de sinais no padr√£o do Backtester
    signals = pd.DataFrame({
        "datetime": df["datetime"],
        "signal": 0,
        "entry_price": np.nan,
        "stop_price": np.nan,
        "take_price": np.nan,
        "size": 1.0,
        "risk": np.nan,
    })

    RR           = 3.0    # TP = 3R
    MAX_AGE      = 100    # FVG expira depois de 100 candles
    MIN_ATR_FACT = 0.25   # risco m√≠nimo = 0.25 * ATR14

    n      = len(df)
    highs  = df["high"].values
    lows   = df["low"].values
    vols   = df["volume"].values
    closes = df["close"].values
    atr14  = df["atr14"].values if "atr14" in df.columns else None
    ema50  = df["ema50"].values

    fvg_validos_volume  = 0
    fvg_validos_tamanho = 0

    # 2) Para cada FVG, achar o primeiro reteste do 50% e montar trade
    for _, row in fvg_df.iterrows():
        base_i   = int(row["index"])   # candle C2
        fvg_type = row["type"]
        top      = float(row["top"])
        bottom   = float(row["bottom"])
        mid      = float(row["mid"])

        # precisa ter espa√ßo pra olhar c0..c3 e candles √† frente
        if base_i >= n - 1 or base_i < 3:
            continue

        # ---------- FILTRO DE TEND√äNCIA COM EMA50 (no candle base) ----------
        ema_now   = ema50[base_i]
        price_ref = closes[base_i]  # close do C2
        if np.isnan(ema_now):
            continue

        # bullish: s√≥ em tend√™ncia de alta (pre√ßo acima da ema)
        if fvg_type == "bullish" and price_ref <= ema_now:
            continue

        # bearish: s√≥ em tend√™ncia de baixa (pre√ßo abaixo da ema)
        if fvg_type == "bearish" and price_ref >= ema_now:
            continue

        # ---------- FILTRO DE VOLUME FINANCEIRO ----------
        v0 = vols[base_i]       # volume do candle que gerou o FVG
        v1 = vols[base_i - 1]   # candle 1 atr√°s
        v2 = vols[base_i - 2]   # candle 2 atr√°s
        v3 = vols[base_i - 3]   # candle 3 atr√°s

        # Candle gerador precisa ter volume MAIOR que os 3 anteriores
        """if not (v0 > v1 and v0 > v2 and v0 > v3):
            continue   # descarta FVG fraco

        fvg_validos_volume += 1"""


        # ---------- JANELA DE VIDA DO FVG ----------
        start_j = base_i + 1
        end_j   = min(n - 1, base_i + MAX_AGE)

        entry_bar = None
        for j in range(start_j, end_j + 1):
            lo_j = lows[j]
            hi_j = highs[j]
            # candle precisa tocar o 50% do FVG
            if lo_j <= mid <= hi_j:
                entry_bar = j
                break

        if entry_bar is None:
            continue  # nunca retestou ‚Üí FVG morto

        # ---------- FILTRO DE TEND√äNCIA NA HORA DA ENTRADA ----------
        ema_entry   = ema50[entry_bar]
        price_entry = closes[entry_bar]
        if np.isnan(ema_entry):
            continue

        if fvg_type == "bullish" and price_entry <= ema_entry:
            # entrada estaria "abaixo" da ema ‚Üí descarta
            continue

        if fvg_type == "bearish" and price_entry >= ema_entry:
            # entrada estaria "acima" da ema ‚Üí descarta
            continue

        # ---------- STOP ATR√ÅS DAS M√çNIMAS/M√ÅXIMAS DO BLOCO ----------
        idx0 = base_i - 2
        idx3 = base_i + 1

        block_lows  = lows[idx0:idx3+1]
        block_highs = highs[idx0:idx3+1]

        if fvg_type == "bullish":
            entry = mid
            sl    = block_lows.min()
            risk  = entry - sl
            if risk <= 0:
                continue
            tp    = entry + RR * risk
            sig   = 1

        elif fvg_type == "bearish":
            entry = mid
            sl    = block_highs.max()
            risk  = sl - entry
            if risk <= 0:
                continue
            tp    = entry - RR * risk
            sig   = -1

        else:
            continue

        # ---------- FILTRO DE RISCO M√çNIMO ----------
        if atr14 is not None and MIN_ATR_FACT > 0:
            min_risk = atr14[base_i] * MIN_ATR_FACT
            if risk < min_risk:
                continue

        fvg_validos_tamanho += 1

        # evita sobrescrever se j√° tiver sinal nesse candle
        if signals.loc[entry_bar, "signal"] == 0:
            signals.loc[entry_bar, "signal"]      = sig
            signals.loc[entry_bar, "entry_price"] = entry
            signals.loc[entry_bar, "stop_price"]  = sl
            signals.loc[entry_bar, "take_price"]  = tp
            signals.loc[entry_bar, "risk"]        = risk

    print("FVGs com volume forte (filtro OFF, s√≥ contagem):", fvg_validos_volume)
    print("FVGs que passaram no filtro de tamanho:", fvg_validos_tamanho)
    print("Sinais de COMPRA gerados:", (signals["signal"] == 1).sum())
    print("Sinais de VENDA gerados :", (signals["signal"] == -1).sum())

    return signals, indicadores_usados



# gera sinais a partir do df_raw
signals, indicadores_usados = generate_signals(df_raw)

"""## 05 ‚Äî Motor de Backtest (gen√©rico, 1 posi√ß√£o por vez)"""

# ============================================================
# BACKTESTER PRO UNIVERSAL
# - Suporta:
#   * single_position_mode (True = s√≥ 1 trade; False = hedge)
#   * SL/TP opcionais (se a estrat√©gia mandar)
#   * trailing_distance opcional (em pre√ßo)
#   * sinais simples (apenas datetime/signal) ou ricos (com colunas extras)
# ============================================================

class Backtester:
    def __init__(self, df: pd.DataFrame, config: dict = None):
        self.df = df.copy().reset_index(drop=True)
        self.df["datetime"] = pd.to_datetime(self.df["datetime"])

        self.config = config or {}
        self.initial_capital      = float(self.config.get("initial_capital", 1000.0))
        self.single_position_mode = bool(self.config.get("single_position_mode", True))
        self.commission_perc      = float(self.config.get("commission_perc", 0.0))  # % do valor nocional
        self.slippage             = float(self.config.get("slippage", 0.0))        # fra√ß√£o do pre√ßo (0.0001 = 0.01%)

    # --------------------------------------------------------
    # Fun√ß√£o principal de backtest
    # --------------------------------------------------------
    def run(self, signals: pd.DataFrame) -> pd.DataFrame:
        capital = self.initial_capital  # equity atual para sizing de 1%

        if signals is None or signals.empty:
            print("‚ö† Signals vazio. Nada a rodar.")
            return pd.DataFrame()

        sig = signals.copy()
        sig["datetime"] = pd.to_datetime(sig["datetime"])

        # join por datetime (garante alinhamento)
        data = pd.merge(
            self.df,
            sig,
            on="datetime",
            how="left",
            suffixes=("", "_sig")
        )

        # se n√£o tiver coluna signal, assume 0
        if "signal" not in data.columns:
            data["signal"] = 0
        data["signal"] = data["signal"].fillna(0).astype(int)

        # flags de colunas extras (opcionais)
        has_stop   = "stop_price" in data.columns
        has_take   = "take_price" in data.columns
        has_size   = "size" in data.columns
        has_risk   = "risk" in data.columns
        has_trail  = "trailing_distance" in data.columns
        has_entry  = "entry_price" in data.columns  # <--- NOVO

        open_trades = []
        closed_trades = []
        trade_id = 0

        # loop candle a candle
        for bar_index, row in enumerate(data.itertuples()):
            dt   = row.datetime
            o    = row.open
            h    = row.high
            l    = row.low
            c    = row.close
            vol  = row.volume
            sigv = row.signal

            # 1) Atualizar trades abertos (MFE/MAE, SL/TP, trailing)
            still_open = []
            for t in open_trades:
                direction = t["direction"]
                size      = t["size"]
                entry_px  = t["entry_price"]

                # --------- MFE / MAE (em dinheiro) ---------
                if direction == "long":
                    best_pnl  = (h - entry_px) * size
                    worst_pnl = (l - entry_px) * size
                else:  # short
                    best_pnl  = (entry_px - l) * size
                    worst_pnl = (entry_px - h) * size

                t["max_favor"]  = max(t["max_favor"], best_pnl)
                t["max_adverse"] = min(t["max_adverse"], worst_pnl)

                exit_reason = None
                exit_price  = None

                # --------- Trailing Stop (opcional) ---------
                if t.get("trailing_distance") is not None:
                    dist = t["trailing_distance"]
                    if direction == "long":
                        new_stop = c - dist
                        if t["stop_price"] is None or np.isnan(t["stop_price"]):
                            t["stop_price"] = new_stop
                        else:
                            t["stop_price"] = max(t["stop_price"], new_stop)
                    else:
                        new_stop = c + dist
                        if t["stop_price"] is None or np.isnan(t["stop_price"]):
                            t["stop_price"] = new_stop
                        else:
                            t["stop_price"] = min(t["stop_price"], new_stop)

                # --------- Checar SL / TP (se existirem) ---------
                sp = t.get("stop_price", None)
                tp = t.get("take_price", None)

                hit_sl = False
                hit_tp = False

                if direction == "long":
                    if sp is not None and not pd.isna(sp) and l <= sp:
                        hit_sl = True
                    if tp is not None and not pd.isna(tp) and h >= tp:
                        hit_tp = True
                else:
                    if sp is not None and not pd.isna(sp) and h >= sp:
                        hit_sl = True
                    if tp is not None and not pd.isna(tp) and l <= tp:
                        hit_tp = True

                if hit_sl or hit_tp:
                    # prioriza SL (abordagem conservadora)
                    if hit_sl:
                        exit_price  = sp
                        exit_reason = "sl"
                    else:
                        exit_price  = tp
                        exit_reason = "tp"

                # --------- Fechamento por SL/TP ---------
                if exit_reason is not None:
                    self._close_trade(
                        t, exit_price, dt, bar_index,
                        exit_reason=exit_reason
                    )
                    closed_trades.append(t)
                    if t["pnl"] is not None:
                        capital += t["pnl"]
                else:
                    still_open.append(t)

            open_trades = still_open

            # 2) Fechamento por sinal (apenas no modo "single position")
            if self.single_position_mode and sigv != 0 and len(open_trades) > 0:
                # fecha trade atual pelo sinal oposto e abre outro (se quiser)
                new_direction = "long" if sigv > 0 else "short"
                updated = []
                for t in open_trades:
                    # fecha todos ‚Äì modo "apenas 1 posi√ß√£o"
                    self._close_trade(
                        t, c, dt, bar_index,
                        exit_reason="signal"
                    )
                    closed_trades.append(t)
                    if t["pnl"] is not None:
                        capital += t["pnl"]
                open_trades = []

                # abre nova posi√ß√£o seguindo o sinal
                if sigv != 0:
                    # Se a estrat√©gia mandou um entry_price (ex.: 50% do FVG), usa.
                    if has_entry:
                        entry_sig = getattr(row, "entry_price", np.nan)
                    else:
                        entry_sig = np.nan

                    price_for_entry = (
                        float(entry_sig) if (entry_sig is not None and not pd.isna(entry_sig))
                        else float(c)
                    )

                    new_trade = self._open_trade_from_row(
                        trade_id, dt, price_for_entry, vol, bar_index,
                        sig_row=row,
                        has_stop=has_stop,
                        has_take=has_take,
                        has_size=has_size,
                        has_risk=has_risk,
                        has_trail=has_trail,
                        capital_now=capital
                    )

                    if new_trade is not None:
                        open_trades.append(new_trade)
                        trade_id += 1

            # 3) Abertura de trades por sinal (modo hedge OU se n√£o h√° nenhum aberto)
            else:
                if sigv != 0:
                    # no modo single, s√≥ abre se n√£o houver trade aberto
                    if self.single_position_mode and len(open_trades) > 0:
                        pass  # j√° foi tratado no bloco 2
                    else:
                        # usa entry_price da estrat√©gia se existir, sen√£o o close
                        if has_entry:
                            entry_sig = getattr(row, "entry_price", np.nan)
                        else:
                            entry_sig = np.nan

                        price_for_entry = (
                            float(entry_sig) if (entry_sig is not None and not pd.isna(entry_sig))
                            else float(c)
                        )

                        new_trade = self._open_trade_from_row(
                            trade_id, dt, price_for_entry, vol, bar_index,
                            sig_row=row,
                            has_stop=has_stop,
                            has_take=has_take,
                            has_size=has_size,
                            has_risk=has_risk,
                            has_trail=has_trail,
                            capital_now=capital
                        )
                        if new_trade is not None:
                            open_trades.append(new_trade)
                            trade_id += 1



        # 4) Fecha o que sobrou no √∫ltimo candle (EOD)
        if len(open_trades) > 0:
            last_row = data.iloc[-1]
            last_dt  = last_row["datetime"]
            last_c   = last_row["close"]
            last_idx = len(data) - 1
            for t in open_trades:
                self._close_trade(
                    t, last_c, last_dt, last_idx,
                    exit_reason="eod"
                )
                closed_trades.append(t)
                if t["pnl"] is not None:
                    capital += t["pnl"]

        if not closed_trades:
            print("‚ö† Nenhum trade fechado.")
            return pd.DataFrame()

        trades_df = pd.DataFrame(closed_trades)

        # duration & result & R:R
        trades_df["duration"] = trades_df["exit_time"] - trades_df["entry_time"]
        trades_df["bars_in_trade"] = trades_df["exit_bar_index"] - trades_df["entry_bar_index"]

        # resultado textual
        trades_df["result"] = np.where(
            trades_df["pnl"] > 0, "win",
            np.where(trades_df["pnl"] < 0, "loss", "be")
        )

        # ============= PATCH CR√çTICO =============
        # risk pode ser None ‚Üí nunca usar abs(None)
        if "risk" not in trades_df.columns:
            trades_df["risk"] = np.nan

        trades_df["risk"] = trades_df["risk"].astype(float)

        # Risk:Reward seguro
        trades_df["risk_reward"] = np.where(
            trades_df["risk"].notna() & (trades_df["risk"] != 0),
            trades_df["pnl"] / trades_df["risk"],
            np.nan
        )

        return trades_df

    # --------------------------------------------------------
    # Abre um trade a partir de um sinal (linha de signals + df)
    # --------------------------------------------------------
    def _open_trade_from_row(
        self, trade_id, dt, price, vol, bar_index,
        sig_row,
        has_stop, has_take, has_size, has_risk, has_trail,
        capital_now
    ):
        sigv = sig_row.signal
        if sigv == 0:
            return None

        direction = "long" if sigv > 0 else "short"

        # Valores vindos do sinal (fallback)
        size_from_signal = float(getattr(sig_row, "size", 1.0)) if has_size else 1.0
        stop_price       = getattr(sig_row, "stop_price", None) if has_stop else None
        take_price       = getattr(sig_row, "take_price", None) if has_take else None
        trailing_distance = getattr(sig_row, "trailing_distance", None) if has_trail else None
        risk             = getattr(sig_row, "risk", None) if has_risk else None

        # Normalizar Nones/NaN
        if stop_price is not None and pd.isna(stop_price):
            stop_price = None
        if take_price is not None and pd.isna(take_price):
            take_price = None
        if trailing_distance is not None and pd.isna(trailing_distance):
            trailing_distance = None
        if risk is not None and pd.isna(risk):
            risk = None

        # Dist√¢ncia de stop em PRE√áO (por unidade)
        per_unit_risk = None
        if stop_price is not None:
            per_unit_risk = abs(price - stop_price)

        # Regra do 1%: tamanho da posi√ß√£o = (1% do capital) / risco em pre√ßo
        risk_pct = float(self.config.get("risk_per_trade_pct", 0.0))
        size = size_from_signal  # fallback padr√£o

        if risk_pct > 0 and per_unit_risk is not None and per_unit_risk > 0:
            risk_frac   = risk_pct / 100.0          # ex.: 1.0 ‚Üí 0.01
            money_risk  = capital_now * risk_frac   # quanto posso perder em $/USDT
            size        = money_risk / per_unit_risk
            risk        = money_risk                # risco monet√°rio do trade (1% do capital)
        else:
            # fallback: se n√£o tem regra do 1% ou n√£o tem stop, estima risco
            if risk is None and per_unit_risk is not None and per_unit_risk > 0:
                risk = per_unit_risk * size

        # Slippage e comiss√£o na ENTRADA
        dir_factor = 1 if direction == "long" else -1
        entry_px   = price * (1 + dir_factor * self.slippage)
        commission_open = self.commission_perc * entry_px * size

        trade = {
            "id": trade_id,
            "direction": direction,
            "entry_time": dt,
            "entry_bar_index": bar_index,
            "entry_price": entry_px,
            "size": size,
            "stop_price": stop_price,
            "take_price": take_price,
            "trailing_distance": trailing_distance,
            "risk": risk,  # em dinheiro (‚âà1% do capital), se conseguiu calcular
            "max_favor": 0.0,
            "max_adverse": 0.0,
            "volume_at_entry": vol,
            "exit_time": None,
            "exit_bar_index": None,
            "exit_price": None,
            "pnl": None,
            "commission_open": commission_open,
            "commission_close": 0.0,
            "exit_reason": None,
        }
        return trade


    # --------------------------------------------------------
    # Fecha trade (c√°lculo de PnL, comiss√£o, etc.)
    # --------------------------------------------------------
    def _close_trade(self, trade, exit_price, exit_time, exit_bar_index, exit_reason="unknown"):
        direction = trade["direction"]
        size      = trade["size"]
        dir_factor = 1 if direction == "long" else -1

        # slippage na sa√≠da
        px = exit_price * (1 - dir_factor * self.slippage)

        commission_close = self.commission_perc * px * size

        gross_pnl = (px - trade["entry_price"]) * size * dir_factor
        net_pnl = gross_pnl - trade.get("commission_open", 0.0) - commission_close

        trade["exit_time"]      = exit_time
        trade["exit_bar_index"] = exit_bar_index
        trade["exit_price"]     = px
        trade["commission_close"] = commission_close
        trade["pnl"]            = net_pnl
        trade["exit_reason"]    = exit_reason

bt = Backtester(df_raw, CONFIG)
trades = bt.run(signals)
print(trades[["commission_open", "commission_close"]].sum())

"""
## 07 ‚Äî Relat√≥rios e Gr√°ficos"""

def show_metrics(trades_df: pd.DataFrame, initial_cap: float):
    m = performance_summary(trades_df, initial_cap)
    order = [
        "initial_capital", "final_balance", "net_profit",
        "trades", "wins", "losses", "win_rate_pct",
        "gross_profit", "gross_loss", "profit_factor",
        "max_drawdown_pct"
    ]
    labels = {
        "initial_capital": "Capital Inicial",
        "final_balance": "Saldo Final",
        "net_profit": "Resultado L√≠quido",
        "trades": "N¬∫ de Trades",
        "wins": "Vit√≥rias",
        "losses": "Derrotas",
        "win_rate_pct": "Taxa de Acerto (%)",
        "gross_profit": "Lucro Bruto",
        "gross_loss": "Preju√≠zo Bruto",
        "profit_factor": "Profit Factor",
        "max_drawdown_pct": "Max Drawdown (%)",
    }
    df = pd.DataFrame(
        {"M√©trica": [labels[k] for k in order],
         "Valor":   [m[k] for k in order]}
    )
    display(df)

def plot_equity(trades_df: pd.DataFrame, initial_cap: float):
    if trades_df.empty:
        print('Sem trades para plotar equity.')
        return
    eq = initial_cap + trades_df['pnl'].cumsum()
    plt.figure()
    plt.plot(eq.index, eq.values)
    plt.title('Equity Curve')
    plt.xlabel('Trade #')
    plt.ylabel('Equity')
    plt.show()

def plot_drawdown(trades_df: pd.DataFrame, initial_cap: float):
    if trades_df.empty:
        print('Sem trades para plotar drawdown.')
        return
    eq = initial_cap + trades_df['pnl'].cumsum()
    dd = compute_drawdown(eq)['drawdown'] * 100.0
    plt.figure()
    plt.plot(dd.index, dd.values)
    plt.title('Drawdown (%)')
    plt.xlabel('Trade #')
    plt.ylabel('DD %')
    plt.show()

print('‚úÖ Relat√≥rios e plots prontos.')

"""## 08 ‚Äî Runner (carrega dados ‚Üí gera sinais ‚Üí roda backtest ‚Üí mostra resultados)"""

import matplotlib.pyplot as plt
import numpy as np

def plot_candles_minimal(df, title="Candles + Volume", figsize=(19.2, 10.8)):
    """
    Gr√°fico minimalista com:
    - Candles em cima
    - Volume embaixo
    - Sem frescura, focado em performance
    """

    print("üü© Gerando gr√°fico minimalista com volume...")

    data = df.copy()
    data.index = pd.to_datetime(data["datetime"])

    opens  = data["open"].values
    highs  = data["high"].values
    lows   = data["low"].values
    closes = data["close"].values
    vols   = data["volume"].values

    x = np.arange(len(data))

    # Figura com 2 subplots (pre√ßo + volume)
    fig, (ax_price, ax_vol) = plt.subplots(
        2, 1,
        figsize=figsize,
        sharex=True,
        gridspec_kw={'height_ratios': [3, 1]}
    )

    # ------- PRE√áO (CANDLES) -------
    up = closes >= opens
    down = closes < opens

    # Pavios
    ax_price.vlines(x[up], lows[up], highs[up], color="green", linewidth=0.4)
    ax_price.vlines(x[down], lows[down], highs[down], color="red", linewidth=0.4)

    # Corpo dos candles
    ax_price.vlines(x[up], opens[up], closes[up], color="green", linewidth=1.0)
    ax_price.vlines(x[down], opens[down], closes[down], color="red", linewidth=1.0)

    ax_price.set_title(title, fontsize=14)
    ax_price.set_ylabel("Pre√ßo")
    ax_price.grid(False)

    # ------- VOLUME -------
    ax_vol.bar(x, vols, width=1.0, color="gray")
    ax_vol.set_ylabel("Volume")
    ax_vol.grid(False)

    # Deixa o layout apertado pra caber tudo
    plt.tight_layout()
    plt.show()

    print("‚úî Gr√°fico pronto!\n")


df = df_raw.copy()  # s√≥ pra manter compatibilidade com blocos antigos
plot_candles_minimal(df, "BTCUSDT - Hist√≥rico Completo")

# ====================================================
#   BLOCOS DE TRADES ‚Äî SEGURO E SEM ERROS
# ====================================================

print("===== LISTA COMPLETA DE TRADES =====")

# 1) Garantir que 'trades' existe
if "trades" not in globals():
    print("‚ö† Vari√°vel 'trades' n√£o existe. Rode o backtest primeiro.")
else:

    # 2) Garantir que √© DataFrame
    if trades is None:
        print("‚ö† 'trades' est√° vazio (None).")
    elif not isinstance(trades, pd.DataFrame):
        print("‚ö† 'trades' n√£o √© um DataFrame. Tipo atual:", type(trades))
    elif trades.empty:
        print("‚ö† Nenhum trade encontrado.")
    else:
        display(trades)


print("\n===== RESUMO - √öLTIMOS TRADES =====")

if "trades" in globals() and isinstance(trades, pd.DataFrame) and not trades.empty:
    display(trades.tail(10))
else:
    print("‚ö† Nada para exibir.")


# ====================================================
#  EXPORTAR TRADES PARA CSV (SEGURAN√áA TOTAL)
# ====================================================

print("\n===== EXPORTANDO TRADES =====")

if "trades" not in globals():
    print("‚ö† Vari√°vel 'trades' n√£o existe. Nenhum arquivo ser√° salvo.")
elif trades is None:
    print("‚ö† 'trades' √© None. Nenhum arquivo ser√° salvo.")
elif not isinstance(trades, pd.DataFrame):
    print("‚ö† 'trades' n√£o √© DataFrame. Tipo:", type(trades))
elif trades.empty:
    print("‚ö† Nenhum trade para exportar.")
else:
    export_path = "/content/trades_resultados.csv"
    trades.to_csv(export_path, index=False)
    print(f"üìÅ Arquivo salvo com sucesso: {export_path}")

# ====================================================
#  M√âTRICAS DA ESTRAT√âGIA ‚Äî ESTILO MT5 (TABELINHA)
# ====================================================

import numpy as np

def mostrar_metricas(trades, initial_capital):
    if trades is None or not isinstance(trades, pd.DataFrame) or trades.empty:
        print("‚ö† N√£o h√° trades suficientes para calcular m√©tricas.")
        return

    df = trades.copy()

    if 'pnl' not in df.columns:
        print("‚ö† Coluna 'pnl' n√£o encontrada nos trades. Sem ela n√£o d√° pra calcular as m√©tricas.")
        return

    # Ordena por tempo de sa√≠da se existir, sen√£o por √≠ndice
    if 'exit_time' in df.columns:
        df = df.sort_values('exit_time').reset_index(drop=True)
    else:
        df = df.reset_index(drop=True)

    total_trades = len(df)

    # Wins / Losses
    wins   = df[df['pnl'] > 0]
    losses = df[df['pnl'] < 0]

    n_wins   = len(wins)
    n_losses = len(losses)

    gross_profit = wins['pnl'].sum() if n_wins   > 0 else 0.0
    gross_loss   = losses['pnl'].sum() if n_losses > 0 else 0.0
    net_profit   = df['pnl'].sum()
    final_balance = initial_capital + net_profit

    win_rate = (n_wins / total_trades * 100.0) if total_trades > 0 else np.nan

    profit_factor = (gross_profit / abs(gross_loss)) if gross_loss < 0 else np.nan

    avg_gain = wins['pnl'].mean()  if n_wins   > 0 else np.nan
    avg_loss = losses['pnl'].mean() if n_losses > 0 else np.nan

    expectancy = net_profit / total_trades if total_trades > 0 else np.nan

    # Equity & Drawdown
    equity_curve = initial_capital + df['pnl'].cumsum()
    peak = equity_curve.cummax()
    dd = equity_curve - peak
    dd_pct = dd / peak * 100.0

    max_dd = dd.min() if len(dd) > 0 else np.nan
    max_dd_pct = dd_pct.min() if len(dd_pct) > 0 else np.nan

    # Trades para recuperar o DD m√°ximo (aprox.)
    recovery_trades = np.nan
    if len(dd_pct) > 0:
        dd_idx = dd_pct.idxmin()
        if dd_idx is not None and dd_idx < len(equity_curve) - 1:
            after = equity_curve[dd_idx:]
            new_high_idx = after.idxmax()
            if equity_curve[new_high_idx] >= peak.iloc[:dd_idx+1].max():
                recovery_trades = int(new_high_idx - dd_idx)

    # Tempo m√©dio em posi√ß√£o e retorno anualizado (se tiver timestamps)
    avg_duration = np.nan
    annual_return_pct = np.nan
    if 'entry_time' in df.columns and 'exit_time' in df.columns:
        entry = pd.to_datetime(df['entry_time'])
        exit_ = pd.to_datetime(df['exit_time'])
        durations = exit_ - entry
        avg_duration = durations.mean()

        start = entry.min()
        end   = exit_.max()
        total_days = (end - start).days

        if total_days and total_days > 0:
            final_balance = equity_curve.iloc[-1]
            annual_return = (final_balance / initial_capital) ** (365 / total_days) - 1
            annual_return_pct = annual_return * 100.0

    # Sharpe simples por trade (usando retorno por trade sobre o capital inicial)
    returns = df['pnl'] / initial_capital
    if returns.std() > 0:
        sharpe = returns.mean() / returns.std() * np.sqrt(total_trades)
    else:
        sharpe = np.nan

    metrics = {
        "Capital Inicial": initial_capital,
        "Saldo Final": final_balance,
        "Total de Trades": total_trades,
        "N√∫mero de Trades Vencedores": n_wins,
        "N√∫mero de Trades Perdedores": n_losses,
        "Taxa de Acerto (%)": win_rate,
        "Lucro Bruto": gross_profit,
        "Preju√≠zo Bruto": gross_loss,
        "Lucro L√≠quido": net_profit,
        "Fator de Lucro (Profit Factor)": profit_factor,
        "M√©dia de Ganhos": avg_gain,
        "M√©dia de Perdas": avg_loss,
        "Expectativa por Trade": expectancy,
        "Max Drawdown (valor)": max_dd,
        "Max Drawdown (%)": max_dd_pct,
        "Trades para Recuperar DD": recovery_trades,
        "Tempo M√©dio em Posi√ß√£o": avg_duration,
        "Taxa de Retorno Anualizada (%)": annual_return_pct,
        "Sharpe Ratio (por trade)": sharpe,
    }

    # Monta a tabelinha
    linhas = []
    for k, v in metrics.items():
        if isinstance(v, (float, int, np.floating)):
            if pd.isna(v):
                linhas.append([k, None])
            else:
                linhas.append([k, round(float(v), 4)])
        else:
            linhas.append([k, v])

    tabela = pd.DataFrame(linhas, columns=["M√©trica", "Valor"])
    print("===== M√âTRICAS DA ESTRAT√âGIA =====")
    display(tabela)

# --------- CHAMAR ASSIM (abaixo do backtest) ---------
if "trades" not in globals():
    print("‚ö† Rode o backtest primeiro (Runner) para gerar os trades.")
else:
    mostrar_metricas(trades, CONFIG['initial_cap'])

"""#09 - Trade Exemplar"""

# ============================================================
# TRADE EXEMPLAR ‚Äî Vers√£o 5.0 (detalhado + sem repetir)
# ============================================================

def plot_trade_exemplar(df, trades, indicadores_da_estrategia):
    import numpy as np
    import matplotlib.pyplot as plt
    global SHOWN_TRADE_IDS

    # ============================
    # 1 ‚Äî VALIDAR TRADE
    # ============================
    if trades is None or trades.empty:
        print("‚ö† N√£o h√° trades para mostrar.")
        return

    tdf = trades.copy()

    # Descobrir qual coluna usar como ID
    id_col = "id" if "id" in tdf.columns else None

    if id_col is not None:
        candidatos = tdf[~tdf[id_col].isin(SHOWN_TRADE_IDS)]
        if candidatos.empty:
            # j√° mostramos todos ‚Üí reset
            SHOWN_TRADE_IDS = set()
            candidatos = tdf
        trade = candidatos.sample(1).iloc[0]
        trade_id = int(trade[id_col])
        SHOWN_TRADE_IDS.add(trade_id)
    else:
        # fallback: usa o pr√≥prio √≠ndice como ID
        candidatos = tdf[~tdf.index.isin(SHOWN_TRADE_IDS)]
        if candidatos.empty:
            SHOWN_TRADE_IDS = set()
            candidatos = tdf
        trade = candidatos.sample(1).iloc[0]
        trade_id = int(trade.name)
        SHOWN_TRADE_IDS.add(trade_id)

    entry_time = pd.to_datetime(trade["entry_time"])
    exit_time  = pd.to_datetime(trade["exit_time"])
    entry_px   = float(trade["entry_price"])
    exit_px    = float(trade["exit_price"])
    direction  = trade["direction"]

    pnl   = float(trade.get("pnl", np.nan))
    risk  = float(trade.get("risk", np.nan)) if "risk" in trade else np.nan
    rr    = pnl / risk if (risk not in (0, np.nan) and np.isfinite(risk) and np.isfinite(pnl)) else np.nan
    result = trade.get("result", None)
    if pd.isna(result):
        if pnl > 0:
            result = "win"
        elif pnl < 0:
            result = "loss"
        else:
            result = "be"

    bars_in_trade = trade.get("bars_in_trade", np.nan)
    duration      = trade.get("duration", None)

    # ============================
    # PRINT DETALHADO
    # ============================
    print("\n===== TRADE EXEMPLAR =====")
    print(f"ID do trade       : {trade_id}")
    print(f"Dire√ß√£o           : {direction.upper()}  | Resultado: {str(result).upper()}")
    print(f"Entrada           : {entry_time}  @ {entry_px:.2f}")
    print(f"Sa√≠da             : {exit_time}   @ {exit_px:.2f}")
    print(f"PnL               : {pnl:.2f}")
    if np.isfinite(risk):
        print(f"Risco (pre√ßo)     : {risk:.2f}")
    if np.isfinite(rr):
        print(f"R m√∫ltiplos (PnL/R): {rr:.2f} R")
    if duration is not None and not pd.isna(duration):
        print(f"Dura√ß√£o           : {duration}")
    if not pd.isna(bars_in_trade):
        print(f"Barras no trade   : {int(bars_in_trade)}")

    # ============================
    # 2 ‚Äî PREPARAR DATAFRAME
    # ============================
    df2 = df.copy()
    df2["dt"] = pd.to_datetime(df2["datetime"])
    df2 = df2.set_index("dt")

    # --- EMA 50 dentro do trade exemplar ---
    if "ema50" not in df2.columns:
        df2["ema50"] = df2["close"].ewm(span=50, adjust=False).mean()

    # garante que a ema50 est√° na lista de indicadores a serem plotados
    if indicadores_da_estrategia is None:
        indicadores_da_estrategia = []
    if "ema50" not in indicadores_da_estrategia:
        indicadores_da_estrategia.append("ema50")


    if entry_time not in df2.index or exit_time not in df2.index:
        print("‚ö† Trade fora do hist√≥rico carregado.")
        return

    entry_i = df2.index.get_loc(entry_time)
    exit_i  = df2.index.get_loc(exit_time)

    # ============================
    # 3 ‚Äî DEFINIR JANELA
    # ============================
    duracao_candles = exit_i - entry_i
    janela = 200
    pad = max((janela - duracao_candles) // 2, 30)

    start_i = max(0, entry_i - pad)
    end_i   = min(len(df2)-1, exit_i + pad)

    win = df2.iloc[start_i:end_i+1].copy()
    win = win.reset_index()  # agora win tem coluna "dt" e √≠ndice 0..N-1

    # ============================
    # 4 ‚Äî VARI√ÅVEIS DE GR√ÅFICO
    # ============================
    opens  = win["open"].values
    highs  = win["high"].values
    lows   = win["low"].values
    closes = win["close"].values
    volume = win["volume"].values

    x = np.arange(len(win))
    up   = closes >= opens
    down = closes < opens

    # ============================
    # 5 ‚Äî FIGURA
    # ============================
    fig = plt.figure(figsize=(19, 12))
    gs = fig.add_gridspec(2, 1, height_ratios=[3,1])
    ax = fig.add_subplot(gs[0])
    axv = fig.add_subplot(gs[1], sharex=ax)

    # ============================
    # 6 ‚Äî PLOTAR CANDLESTICKS
    # ============================
    ax.vlines(x[up],   lows[up], highs[up], color='green', linewidth=0.6)
    ax.vlines(x[down], lows[down], highs[down], color='red', linewidth=0.6)

    ax.vlines(x[up],   opens[up], closes[up], color='green', linewidth=2.1)
    ax.vlines(x[down], opens[down], closes[down], color='red', linewidth=2.1)

    # ============================
    # 7 ‚Äî PLOTAR FVG NO GR√ÅFICO
    # ============================
    try:
        fvg = detect_fvg(df)  # detecta no df original

        # Mapear datetime ‚Üí √≠ndice global
        global_dt_to_idx = {d: i for i, d in enumerate(pd.to_datetime(df["datetime"]))}

        # Mapear √≠ndice global ‚Üí √≠ndice local da janela win
        local_map = {}
        for local_i, row in win.iterrows():
            dt = row["dt"]
            if dt in global_dt_to_idx:
                global_i = global_dt_to_idx[dt]
                local_map[global_i] = local_i

        for _, row in fvg.iterrows():
            base_idx = int(row["index"])

            # FVG est√° dentro da janela?
            if base_idx not in local_map:
                continue

            local_start = local_map[base_idx]

            top = float(row["top"])
            bottom = float(row["bottom"])
            mid = float(row["mid"])
            color = "green" if row["type"] == "bullish" else "red"

            # encontrar onde o pre√ßo toca o MID (mitiga√ß√£o)
            local_end = local_start + 50  # limite m√°ximo
            for j in range(local_start, min(local_start + 50, len(win))):
                lo = win["low"].iloc[j]
                hi = win["high"].iloc[j]
                if lo <= mid <= hi:
                    local_end = j
                    break

            # desenhar caixa apenas at√© o ponto de mitiga√ß√£o
            ax.add_patch(
                plt.Rectangle(
                    (local_start, bottom),
                    local_end - local_start,
                    top - bottom,
                    linewidth=1,
                    edgecolor=color,
                    facecolor=color,
                    alpha=0.20,
                    zorder=0
                )
            )

    except Exception as e:
        print("ERRO AO PLOTAR FVG:", e)

    # ============================
    # 8 ‚Äî INDICADORES
    # ============================
    for ind in indicadores_da_estrategia:
        if ind in win.columns:
            ax.plot(x, win[ind].values, linewidth=1.8, label=ind)

    if indicadores_da_estrategia:
        ax.legend(loc="upper left")

    # ============================
    # 9 ‚Äî SETAS DE ENTRADA/SA√çDA
    # ============================
    px_min = win["low"].min()
    px_max = win["high"].max()
    offs = (px_max - px_min) * 0.015

    entry_local = entry_i - start_i
    exit_local  = exit_i - start_i

    if direction == "long":
        ax.scatter(entry_local, win["low"].iloc[entry_local] - offs,
                   s=260, color="lime", edgecolor="black", marker="^", zorder=10)
        ax.scatter(exit_local, win["high"].iloc[exit_local] + offs,
                   s=260, color="yellow", edgecolor="black", marker="v", zorder=10)
    else:
        ax.scatter(entry_local, win["high"].iloc[entry_local] + offs,
                   s=260, color="red", edgecolor="black", marker="v", zorder=10)
        ax.scatter(exit_local, win["low"].iloc[exit_local] - offs,
                   s=260, color="purple", edgecolor="black", marker="^", zorder=10)

    # ============================
    # 10 ‚Äî SL / TP
    # ============================
    sl = trade.get("stop_price")
    tp = trade.get("take_price")

    ax.hlines(entry_px, xmin=0, xmax=len(win)-1, colors="blue", linestyles="--", linewidth=1.2)

    if sl is not None and not pd.isna(sl):
        ax.hlines(sl, xmin=0, xmax=len(win)-1, colors="red", linestyles="--", linewidth=1.4)

    if tp is not None and not pd.isna(tp):
        ax.hlines(tp, xmin=0, xmax=len(win)-1, colors="green", linestyles="--", linewidth=1.4)

    # ============================
    # 11 ‚Äî LAYOUT FINAL
    # ============================
    ax.set_title("Trade Exemplar ‚Äî com FVG desenhado", fontsize=18)
    ax.set_ylabel("Pre√ßo")
    ax.grid(False)

    axv.bar(x, volume, color="gray", width=1)
    axv.set_ylabel("Volume")
    axv.grid(False)

    plt.tight_layout()
    plt.show()

SHOWN_TRADE_IDS = set()  # uma vez por sess√£o
plot_trade_exemplar(df_raw, trades, indicadores_da_estrategia=indicadores_usados)

# ============================================================
# FERRAMENTAS PARA GR√ÅFICOS AVAN√áADOS (MT5 + StrategyQuant)
# ============================================================

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid")
plt.rcParams["figure.figsize"] = (16, 7)


def safe_float(x):
    try: return float(x)
    except: return np.nan

# ============================================================
# EQUITY CURVE ‚Äî VERS√ÉO ORIGINAL + TEMA CYBERPUNK
# ============================================================

def plot_equity_curve(trades, initial_capital):
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd

    if trades is None or trades.empty:
        print("‚ö† Nenhum trade para plotar.")
        return

    # ----------------------------
    # 1. Estilo Cyberpunk
    # ----------------------------
    try:
        import mplcyberpunk
        plt.style.use("cyberpunk")
        glow = True
    except:
        plt.style.use("dark_background")
        glow = False

    # ----------------------------
    # 2. L√≥gica 100% igual ao seu c√≥digo original
    # ----------------------------
    trades_sorted = trades.sort_values("exit_time").reset_index(drop=True)

    # equity come√ßa em 0 no c√≥digo original ‚Üí agora somamos capital
    equity = initial_capital + trades_sorted["pnl"].cumsum()

    # eixo X = √≠ndice puro (como seu gr√°fico original)
    x = np.arange(len(equity))

    # ----------------------------
    # 3. Plot id√™ntico ao original, mas bonito
    # ----------------------------
    fig, ax = plt.subplots(figsize=(18, 5))

    # linha neon
    ax.plot(x, equity.values, color="#00FFF6", linewidth=2.5)

    # preenchimento inferior
    ax.fill_between(x, equity.values, initial_capital,
                    alpha=0.15, color="#00FFF6")

    # linha do capital inicial
    ax.axhline(initial_capital, linestyle="--", linewidth=1,
               color="#AAAAAA", alpha=0.6)

    # t√≠tulos
    ax.set_title("EQUITY CURVE ‚Äì ESTRAT√âGIA", fontsize=15, weight="bold")
    ax.set_ylabel("Equity")
    ax.set_xlabel("Trades")
    ax.grid(True, alpha=0.3)

    # brilho
    if glow:
        mplcyberpunk.add_glow_effects(ax)

    plt.tight_layout()
    plt.savefig("equity_total.png", dpi=130, bbox_inches="tight")
    plt.show()



# ============================================================
# EQUITY POR ANO ‚Äî ESTILO SIMPLES
# ============================================================

def plot_equity_por_ano(trades, initial_capital):
    if trades is None or trades.empty:
        print("‚ö† Sem trades para equity anual.")
        return

    df = trades.copy()
    df["exit_time"] = pd.to_datetime(df["exit_time"])
    df = df.sort_values("exit_time").reset_index(drop=True)

    df["equity"] = initial_capital + df["pnl"].cumsum()
    df["year"] = df["exit_time"].dt.year

    anos = sorted(df["year"].unique())

    for ano in anos:
        sub = df[df["year"] == ano]
        if sub.empty:
            continue

        plt.figure(figsize=(12, 4))
        plt.plot(sub["exit_time"], sub["equity"], linewidth=2)
        plt.title(f"Equity Curve ‚Äî Ano {ano}")
        plt.xlabel("Data")
        plt.ylabel("Equity")
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        filename = f"equity_year_{ano}.png"
        plt.savefig(filename, dpi=130, bbox_inches="tight")
        print(f"[OK] Gerado: {filename}")
        plt.show()


# ============================================================
# EQUITY ‚Äî √öLTIMOS 3 MESES (ESTILO SIMPLES)
# ============================================================

def plot_equity_ultimos_3_meses(trades, initial_capital):
    if trades is None or trades.empty:
        print("‚ö† Sem trades para equity recente (3 meses).")
        return

    df = trades.copy()
    df["exit_time"] = pd.to_datetime(df["exit_time"])
    df = df.sort_values("exit_time").reset_index(drop=True)

    df["equity"] = initial_capital + df["pnl"].cumsum()

    max_date = df["exit_time"].max()
    min_date = max_date - pd.DateOffset(months=3)

    sub = df[df["exit_time"] >= min_date]
    if sub.empty:
        print("‚ö† Estrat√©gia n√£o possui trades nos √∫ltimos 3 meses.")
        return

    plt.figure(figsize=(12, 4))
    plt.plot(sub["exit_time"], sub["equity"], linewidth=2, color="orange")
    plt.title("Equity ‚Äî √öltimos 3 Meses")
    plt.xlabel("Data")
    plt.ylabel("Equity")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig("equity_last_3m.png", dpi=130, bbox_inches="tight")
    plt.show()


# ============================================================
# HISTOGRAMAS ‚Äî CYBERPUNK / NEON STYLE
# ============================================================

def plot_histograms(trades):
    import matplotlib.pyplot as plt
    import numpy as np

    if trades is None or trades.empty:
        print("‚ö† Sem trades para plotar histogramas.")
        return

    # Tema cyberpunk
    try:
        import mplcyberpunk
        plt.style.use("cyberpunk")
        use_cyber = True
    except ImportError:
        plt.style.use("dark_background")
        use_cyber = False

    fig, ax = plt.subplots(1, 3, figsize=(24, 6))

    # =========================
    # 1) Histograma de PnL
    # =========================
    ax[0].hist(trades["pnl"], bins=40,
               color="#00FFF6", alpha=0.85,
               edgecolor="#FFFFFF", linewidth=0.3)
    ax[0].axvline(0, color="#BBBBBB", linestyle="--", linewidth=1)
    ax[0].set_title("Histograma de Lucro por Trade")
    ax[0].set_xlabel("PnL")
    ax[0].set_ylabel("Frequ√™ncia")

    # =========================
    # 2) Histograma de Risk:Reward
    # =========================
    if "risk" in trades.columns and trades["risk"].notna().any():
        rr = trades["pnl"] / trades["risk"].replace(0, np.nan)
    else:
        rr = np.zeros(len(trades))  # fallback seguro (mesma l√≥gica)

    ax[1].hist(rr, bins=40,
               color="#FF6BF3", alpha=0.85,
               edgecolor="#FFFFFF", linewidth=0.3)
    ax[1].axvline(0, color="#BBBBBB", linestyle="--", linewidth=1)
    ax[1].set_title("Histograma de Risk:Reward")
    ax[1].set_xlabel("R m√∫ltiplos")
    ax[1].set_ylabel("Frequ√™ncia")

    # =========================
    # 3) Histograma de Dura√ß√£o
    # =========================
    if "duration" in trades.columns and trades["duration"].notna().any():
        dur = trades["duration"].dt.total_seconds() / 3600
    else:
        dur = np.zeros(len(trades))  # mesma l√≥gica de fallback

    ax[2].hist(dur, bins=40,
               color="#FFC300", alpha=0.85,
               edgecolor="#FFFFFF", linewidth=0.3)
    ax[2].set_title("Dura√ß√£o dos Trades (Horas)")
    ax[2].set_xlabel("Horas")
    ax[2].set_ylabel("Frequ√™ncia")

    # Est√©tica geral
    for a in ax:
        a.grid(True, alpha=0.25)
        a.set_facecolor("#050814")

    if use_cyber:
        # Glow nas linhas de refer√™ncia
        mplcyberpunk.add_glow_effects(ax[0])
        mplcyberpunk.add_glow_effects(ax[1])
        mplcyberpunk.add_glow_effects(ax[2])

    plt.tight_layout()
    plt.savefig("histograms.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_heatmap_trades(trades):
    import numpy as np
    import pandas as pd
    import seaborn as sns
    import matplotlib.pyplot as plt

    if trades is None or trades.empty:
        print("‚ö† Sem trades para heatmap.")
        return

    df = trades.copy()
    df["exit_time"] = pd.to_datetime(df["exit_time"])
    df["weekday"] = df["exit_time"].dt.weekday
    df["hour"] = df["exit_time"].dt.hour

    pivot = df.pivot_table(
        values="pnl",
        index="weekday",
        columns="hour",
        aggfunc="mean"
    )

    # Cria√ß√£o correta da figura
    fig, ax = plt.subplots(figsize=(14, 6))

    sns.heatmap(
        pivot,
        cmap="viridis",
        annot=False,
        linewidths=0.1,
        linecolor="gray",
        cbar_kws={"label": "Lucro M√©dio"},
        ax=ax
    )

    ax.set_title("Heatmap de Lucro por Dia/Hora")
    ax.set_xlabel("Hora do Dia")
    ax.set_ylabel("Dia da Semana")

    fig.tight_layout()

    # MOSTRA no notebook
    plt.show()

    # SALVA para o HTML
    fig.savefig("heatmap_trades.png", dpi=130, bbox_inches="tight")
    plt.close(fig)

    print("[OK] heatmap_trades.png salvo.")



def plot_scatter_relations(trades):
    import matplotlib.pyplot as plt
    import pandas as pd

    if trades is None or trades.empty:
        print("‚ö† Sem trades para an√°lise de scatter.")
        return

    df = trades.copy()

    # Converter dura√ß√£o timedelta ‚Üí minutos
    if pd.api.types.is_timedelta64_dtype(df["duration"]):
        df["duration_minutes"] = df["duration"] / pd.Timedelta(minutes=1)
    else:
        df["duration_minutes"] = df["duration"]

    # Colunas do seu dataframe
    col_runup     = "max_favor"
    col_drawdown  = "max_adverse"
    col_duration  = "duration_minutes"
    col_pnl       = "pnl"

    # Verifica√ß√£o de seguran√ßa
    for col in [col_runup, col_drawdown, col_duration, col_pnl]:
        if col not in df.columns:
            print(f"‚ùå ERRO: coluna '{col}' n√£o existe no dataframe.")
            print("Colunas dispon√≠veis:", list(df.columns))
            return

    # =====================================================
    # CRIA FIGURA COM 3 SUBPLOTS
    # =====================================================
    fig, axes = plt.subplots(1, 3, figsize=(20, 6))

    # 1 ‚Äî Max Favor√°vel vs Lucro
    axes[0].scatter(df[col_runup], df[col_pnl], alpha=0.6, s=30, color="#00e5ff")
    axes[0].set_title("Max Favor√°vel vs Lucro")
    axes[0].set_xlabel("Max Favor√°vel")
    axes[0].set_ylabel("Lucro")

    # 2 ‚Äî Max Adverso vs Lucro
    axes[1].scatter(df[col_drawdown], df[col_pnl], alpha=0.6, s=30, color="#ff3b3b")
    axes[1].set_title("Max Adverso vs Lucro")
    axes[1].set_xlabel("Max Adverso")
    axes[1].set_ylabel("Lucro")

    # 3 ‚Äî Dura√ß√£o vs Lucro
    axes[2].scatter(df[col_duration], df[col_pnl], alpha=0.6, s=30, color="#00ff44")
    axes[2].set_title("Dura√ß√£o vs Lucro (minutos)")
    axes[2].set_xlabel("Dura√ß√£o (min)")
    axes[2].set_ylabel("Lucro")

    fig.tight_layout()

    # MOSTRA NO NOTEBOOK
    plt.show()

    # SALVA O PNG PARA O HTML
    fig.savefig("scatter_relations.png", dpi=130, bbox_inches="tight")
    plt.close(fig)

    print("[OK] scatter_relations.png salvo.")




# ============================================================
# DRAWDOWN MENSAL ‚Äî CYBERPUNK / NEON STYLE (L√ìGICA ORIGINAL)
# ============================================================

def plot_drawdown_mensal(trades, initial_capital):
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd

    if trades is None or trades.empty:
        print("‚ö† Sem trades para gerar drawdown mensal.")
        return

    # ---------------------------------------------------------
    # Tema Cyberpunk Glow
    # ---------------------------------------------------------
    try:
        import mplcyberpunk
        plt.style.use("cyberpunk")
        use_cyber = True
    except:
        plt.style.use("dark_background")
        use_cyber = False

    # ---------------------------------------------------------
    # 1. L√≥gica ORIGINAL (N√ÉO ALTERAR)
    # ---------------------------------------------------------
    df = trades.copy()
    df["exit_time"] = pd.to_datetime(df["exit_time"])
    df = df.sort_values("exit_time").reset_index(drop=True)

    df["equity"] = initial_capital + df["pnl"].cumsum()
    df["peak"]   = df["equity"].cummax()
    df["dd_pct"] = (df["equity"] - df["peak"]) / df["peak"] * 100.0

    df["month"] = df["exit_time"].dt.to_period("M")
    monthly_dd = df.groupby("month")["dd_pct"].min()

    full_index = pd.period_range(start=monthly_dd.index.min(),
                                 end=monthly_dd.index.max(),
                                 freq="M")
    monthly_dd = monthly_dd.reindex(full_index).fillna(0.0)

    dd_df = monthly_dd.to_frame(name="dd_pct").reset_index()
    dd_df.rename(columns={"index": "month"}, inplace=True)
    dd_df["month_dt"] = dd_df["month"].dt.to_timestamp()
    dd_df["label"] = dd_df["month_dt"].dt.strftime("%m/%Y")

    x = np.arange(len(dd_df))
    y = dd_df["dd_pct"].values

    bar_width = max(0.15, 0.8 - len(x) * 0.0015)
    bar_width = min(bar_width, 0.6)

    # ---------------------------------------------------------
    # 2. Plot Cyberpunk
    # ---------------------------------------------------------
    fig, ax = plt.subplots(figsize=(22, 6))

    bars = ax.bar(
        x,
        y,
        width=bar_width,
        color="#FF4E4E",     # neon red
        alpha=0.85,
        edgecolor="#FFAAAA",
        linewidth=0.4
    )

    # linha 0%
    ax.axhline(0, color="#BBBBBB", linewidth=1)

    # labels dentro da barra
    for bar, v in zip(bars, y):
        ax.text(
            bar.get_x() + bar.get_width() / 2,
            v - (abs(v) * 0.12 + 0.4),
            f"{v:.0f}%",
            ha="center",
            va="top",
            fontsize=8,
            color="white",
            bbox=dict(
                facecolor="black",
                alpha=0.4,
                boxstyle="round,pad=0.2"
            )
        )

    ax.set_xticks(x)
    ax.set_xticklabels(dd_df["label"], rotation=90)

    ax.set_ylabel("Drawdown (%)")
    ax.set_title(
        "SIMULA√á√ÉO DE DRAWDOWN MENSAL ‚Äì ESTRAT√âGIA",
        fontsize=15,
        weight="bold"
    )

    ax.set_ylim(min(y) * 1.35, 4)
    ax.grid(True, axis="y", alpha=0.25)

    # Glow cyberpunk
    if use_cyber:
        mplcyberpunk.add_glow_effects(ax)

    plt.tight_layout()
    plt.savefig("drawdown_mensal.png", dpi=130, bbox_inches="tight")
    plt.show()



plot_equity_curve(trades, CONFIG["initial_cap"])
plot_drawdown_mensal(trades, CONFIG["initial_cap"])
plot_equity_por_ano(trades, CONFIG["initial_cap"])
plot_equity_ultimos_3_meses(trades, CONFIG["initial_cap"])
plot_histograms(trades)
plot_heatmap_trades(trades)
plot_scatter_relations(trades)

from mpl_toolkits.mplot3d import Axes3D

# ============================================================
# PLOT 3D ‚Äî agora detecta automaticamente o ATR existente
# ============================================================
def plot_3d_atr_volume_price(df):
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D  # obrigat√≥rio no Colab

    # Detectar automaticamente a coluna de ATR
    atr_col = next((c for c in df.columns if "atr" in c.lower()), None)

    if atr_col is None:
        raise ValueError(
            "Nenhuma coluna de ATR encontrada. "
            "Certifique-se que 'add_atr(df)' foi executado antes."
        )

    print(f"[INFO] Usando coluna ATR detectada: {atr_col}")

    # Criar figura
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection="3d")

    xs = df["close"].astype(float)
    ys = df["volume"].astype(float)
    zs = df[atr_col].astype(float)

    ax.scatter(xs, ys, zs, s=5, c=zs, cmap="viridis")

    ax.set_xlabel("Close")
    ax.set_ylabel("Volume")
    ax.set_zlabel(atr_col.upper())

    plt.title("Scatter 3D ‚Äî Close x Volume x ATR")
    plt.savefig("plot_3d_atr_volume_price.png", dpi=130, bbox_inches="tight")
    plt.show()


def plot_monthly_profit(trades):
    trades["month"] = trades["exit_time"].dt.to_period("M")
    month_pnl = trades.groupby("month")["pnl"].sum()

    plt.figure(figsize=(20,6))
    month_pnl.plot(kind="bar", color="steelblue")
    plt.title("Lucro Acumulado por M√™s")
    plt.ylabel("PnL")
    plt.grid(True, axis="y")
    plt.savefig("monthly_profit.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_profit_factor_by_month(trades):
    trades["month"] = trades["exit_time"].dt.to_period("M")

    pf = trades.groupby("month").apply(
        lambda x: (x[x["pnl"]>0]["pnl"].sum() /
                   abs(x[x["pnl"]<0]["pnl"].sum()) )
                  if abs(x[x["pnl"]<0]["pnl"].sum()) > 0 else np.nan
    )

    plt.figure(figsize=(20,6))
    pf.plot(kind="bar", color="orange")
    plt.title("Profit Factor por M√™s")
    plt.ylabel("Profit Factor")
    plt.grid(True, axis="y")
    plt.savefig("profit_factor_by_month.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_yearly_profit(trades):
    trades["year"] = trades["exit_time"].dt.year
    pnl = trades.groupby("year")["pnl"].sum()

    plt.figure(figsize=(14,6))
    pnl.plot(kind="bar", color="purple")
    plt.title("Lucro Total por Ano")
    plt.ylabel("PnL")
    plt.grid(True, axis="y")
    plt.savefig("yearly_profit.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_best_and_worst_trades(trades, top=20):
    best = trades.nlargest(top, "pnl")
    worst = trades.nsmallest(top, "pnl")

    fig, ax = plt.subplots(1,2, figsize=(26,7))
    ax[0].bar(range(len(best)), best["pnl"], color="green")
    ax[0].set_title(f"Top {top} Trades (Melhores)")

    ax[1].bar(range(len(worst)), worst["pnl"], color="red")
    ax[1].set_title(f"Top {top} Trades (Piores)")

    plt.savefig("best_worst_trades.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_volatility_vs_pnl(df, trades):
    vol = df["high"] - df["low"]
    n = min(len(vol), len(trades))
    vol = vol[:n]
    pnl = trades["pnl"][:n]

    plt.figure(figsize=(14,6))
    plt.scatter(vol, pnl, alpha=0.5)
    plt.title("Volatilidade √ó Lucro")
    plt.xlabel("High-Low")
    plt.ylabel("PnL")
    plt.grid(True)
    plt.savefig("volatility_vs_pnl.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_boxplot_weekday(trades):
    trades["weekday"] = trades["exit_time"].dt.dayofweek
    plt.figure(figsize=(14,6))
    sns.boxplot(data=trades, x="weekday", y="pnl")
    plt.title("Distribui√ß√£o de Lucro por Dia da Semana")
    plt.xlabel("Dia da Semana (0=Segunda)")
    plt.grid(True)
    plt.savefig("boxplot_weekday.png", dpi=130, bbox_inches="tight")
    plt.show()

def plot_boxplot_hour(trades):
    trades["hour"] = trades["exit_time"].dt.hour
    plt.figure(figsize=(14,6))
    sns.boxplot(data=trades, x="hour", y="pnl")
    plt.title("Distribui√ß√£o de Lucro por Hora do Dia")
    plt.xlabel("Hora")
    plt.grid(True)
    plt.savefig("boxplot_hour.png", dpi=130, bbox_inches="tight")
    plt.show()

def full_dashboard(df, trades):

    print("===== 3D ATR/VOL/PnL =====")
    plot_3d_atr_volume_price(df_raw)

    print("===== LUCRO POR M√äS =====")
    plot_monthly_profit(trades)

    print("===== PROFIT FACTOR POR M√äS =====")
    plot_profit_factor_by_month(trades)

    print("===== LUCRO POR ANO =====")
    plot_yearly_profit(trades)

    print("===== BEST & WORST =====")
    plot_best_and_worst_trades(trades)

    print("===== VOLATILIDADE √ó PNL =====")
    plot_volatility_vs_pnl(df, trades)

    print("===== BOXPLOT SEMANAL =====")
    plot_boxplot_weekday(trades)

    print("===== BOXPLOT HOR√ÅRIO =====")
    plot_boxplot_hour(trades)

full_dashboard(df, trades)

"""#10 - Monte Carlo"""

# ============================================================
# ANALISE AVAN√áADA PRO ‚Äî MONTE CARLO, ROBUSTEZ, R-MULTIPLES
# ============================================================

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid")


# ============================================================
# 1) MONTE CARLO ‚Äî ROLOU MESMO OU FOI SORTE?
# ============================================================

# ============================================================
# GERA SINAIS USANDO EMA FAST / SLOW (para robustez / heatmap)
# ============================================================
def generate_signals_ema_param(df, fast_period=9, slow_period=21):
    df = df.copy()

    df["ema_fast"] = df["close"].ewm(span=fast_period).mean()
    df["ema_slow"] = df["close"].ewm(span=slow_period).mean()

    df["signal"] = 0
    df.loc[df["ema_fast"] > df["ema_slow"], "signal"] = 1
    df.loc[df["ema_fast"] < df["ema_slow"], "signal"] = -1

    # DataFrame final: datetime + signal
    return df[["datetime", "signal"]]


def monte_carlo_equity(trades, initial_capital=1000.0, n_sims=200, mode="shuffle"):
    """
    Gera n_sims curvas de equity simuladas a partir da sequ√™ncia de PnL.
    mode = 'shuffle'   -> embaralha ordem dos trades (permuta)
    mode = 'bootstrap' -> amostra com reposi√ß√£o (tamanho igual ao original)
    Retorna: np.ndarray (n_sims, n_trades)
    """
    pnl = trades["pnl"].values
    n = len(pnl)
    sims = []

    for i in range(n_sims):
        if mode == "bootstrap":
            sample = np.random.choice(pnl, size=n, replace=True)
        else:  # shuffle
            sample = np.random.permutation(pnl)

        eq = initial_capital + np.cumsum(sample)
        sims.append(eq)

    return np.array(sims)


def plot_monte_carlo(trades, initial_capital=1000.0, n_sims=200, mode="shuffle"):
    """
    Plota v√°rias curvas de Monte Carlo + curva original.
    """
    if trades is None or trades.empty:
        print("‚ö† Nenhum trade para Monte Carlo.")
        return

    sims = monte_carlo_equity(trades, initial_capital, n_sims, mode)
    pnl = trades.sort_values("exit_time")["pnl"].values
    eq_real = initial_capital + np.cumsum(pnl)

    plt.figure(figsize=(18, 8))
    for i in range(min(100, n_sims)):
        plt.plot(sims[i], color="gray", alpha=0.08)

    plt.plot(eq_real, color="cyan", linewidth=2, label="Equity Real")
    plt.title(f"Monte Carlo ({n_sims} simula√ß√µes ‚Äî modo {mode})")
    plt.xlabel("Trade")
    plt.ylabel("Equity")
    plt.legend()
    plt.grid(True)
    plt.savefig("monte_carlo_equity.png", dpi=130, bbox_inches="tight")
    plt.show()


def plot_monte_carlo_distribution(trades, initial_capital=1000.0, n_sims=1000, mode="bootstrap"):
    """
    Distribui√ß√£o do saldo final e drawdown m√°ximo nas simula√ß√µes.
    """
    if trades is None or trades.empty:
        print("‚ö† Nenhum trade para Monte Carlo.")
        return

    sims = monte_carlo_equity(trades, initial_capital, n_sims, mode)
    final_eq = sims[:, -1]

    # drawdown m√°ximo em cada simula√ß√£o
    max_dd_list = []
    for eq in sims:
        cummax = np.maximum.accumulate(eq)
        dd = eq - cummax
        max_dd_list.append(dd.min())
    max_dd = np.array(max_dd_list)

    fig, ax = plt.subplots(1, 2, figsize=(18, 6))

    ax[0].hist(final_eq, bins=40, color="steelblue", edgecolor="black")
    ax[0].set_title("Distribui√ß√£o do Saldo Final (Monte Carlo)")
    ax[0].grid(True)

    ax[1].hist(max_dd, bins=40, color="red", edgecolor="black")
    ax[1].set_title("Distribui√ß√£o do Max Drawdown (Monte Carlo)")
    ax[1].grid(True)

    plt.tight_layout()
    plt.savefig("monte_carlo_distribution.png", dpi=130, bbox_inches="tight")
    plt.show()

    print(f"Saldo final (MC) ‚Äî m√©dia: {final_eq.mean():.2f}, mediana: {np.median(final_eq):.2f}")
    print(f"Max DD (MC) ‚Äî m√©dia: {max_dd.mean():.2f}, pior caso: {max_dd.min():.2f}")


def ema_grid_robustness(df, config, fast_range=range(5, 15), slow_range=range(15, 35)):
    """
    Roda um grid de EMAs (fast x slow) e mede lucro l√≠quido.
    Retorna: matrix (len(fast_range) x len(slow_range)), listas fast_list, slow_list
    """
    fast_list = list(fast_range)
    slow_list = list(slow_range)

    results = np.full((len(fast_list), len(slow_list)), np.nan)

    for i, f in enumerate(fast_list):
        for j, s in enumerate(slow_list):
            if f >= s:  # filtro para n√£o usar EMA r√°pida >= lenta
                continue
            signals = generate_signals_ema_param(df, fast_period=f, slow_period=s)
            bt = Backtester(df, config)
            tr = bt.run(signals)
            if tr is None or tr.empty:
                metric = np.nan
            else:
                metric = tr["pnl"].sum()  # lucro l√≠quido total
            results[i, j] = metric

    return results, fast_list, slow_list


def plot_ema_robustness_heatmap(df, config,
                                fast_range=range(5, 15),
                                slow_range=range(15, 35)):
    """
    Plota heatmap de robustez de par√¢metros (lucro l√≠quido).
    """
    res, fast_list, slow_list = ema_grid_robustness(df, config, fast_range, slow_range)

    plt.figure(figsize=(10, 8))
    sns.heatmap(res, xticklabels=slow_list, yticklabels=fast_list, cmap="RdYlGn", center=0)
    plt.xlabel("EMA Lenta")
    plt.ylabel("EMA R√°pida")
    plt.title("Mapa de Robustez ‚Äî Lucro por (EMA R√°pida x Lenta)")
    plt.savefig("ema_robustness_heatmap.png", dpi=130, bbox_inches="tight")
    plt.show()


# ============================================================
# 3) R-MULTIPLES & KELLY
# ============================================================

def compute_r_multiples(trades):
    """
    Calcula R-Multiples usando max_adverse como proxy de risco.
    (Ideia: quanto o trade andou CONTRA voc√™ = risco exposto)
    """
    tr = trades.copy()

    # max_adverse √© negativo (pior excurs√£o). Usamos o m√≥dulo.
    base_risk = tr["max_adverse"].abs()
    base_risk = base_risk.replace(0, np.nan)

    tr["R"] = tr["pnl"] / base_risk
    return tr


def summarize_r_and_kelly(trades):
    """
    Imprime estat√≠sticas de R-Multiples e Kelly Fraction.
    """
    tr = compute_r_multiples(trades)
    r = tr["R"].replace([np.inf, -np.inf], np.nan).dropna()

    if r.empty:
        print("‚ö† N√£o foi poss√≠vel calcular R-Multiples (risco zero ou dados insuficientes).")
        return

    wins  = tr[tr["pnl"] > 0]
    losses = tr[tr["pnl"] < 0]

    win_rate = len(wins) / len(tr) if len(tr) > 0 else 0
    avg_win  = wins["pnl"].mean() if not wins.empty else 0
    avg_loss = losses["pnl"].mean() if not losses.empty else 0  # negativo

    if avg_loss >= 0:
        R_avg = np.nan
    else:
        R_avg = avg_win / abs(avg_loss)

    expectancy = r.mean()

    # F√≥rmula Kelly cl√°ssica: f* = p - q/R
    if R_avg is not np.nan and R_avg is not None and R_avg > 0:
        kelly = win_rate - (1 - win_rate) / R_avg
    else:
        kelly = np.nan

    print("===== R-MULTIPLES & KELLY =====")
    print(f"N trades considerados: {len(tr)}")
    print(f"M√©dia de R: {expectancy:.3f}")
    print(f"Win rate: {win_rate*100:.2f}%")
    print(f"Avg Win: {avg_win:.2f}")
    print(f"Avg Loss: {avg_loss:.2f}")
    print(f"R m√©dio (AvgWin/|AvgLoss|): {R_avg:.3f}" if not np.isnan(R_avg) else "R m√©dio: N/A")
    print(f"Kelly Fraction (te√≥rico): {kelly:.3f}" if not np.isnan(kelly) else "Kelly: N/A")

    # Histograma de R
    plt.figure(figsize=(10, 4))
    plt.hist(r, bins=50, color="gray", edgecolor="black")
    plt.title("Histograma de R-Multiples")
    plt.xlabel("R")
    plt.ylabel("Frequ√™ncia")
    plt.grid(True)
    plt.savefig("r_multiples_hist.png", dpi=130, bbox_inches="tight")
    plt.show()


# ============================================================
# 4) FUN√á√ÉO RESUMO ‚Äî RODAR TUDO DE UMA VEZ
# ============================================================

def advanced_analysis_dashboard(df, trades, config, initial_capital=1000.0):
    """
    Roda tudo: Monte Carlo, Robustez EMA, R-Multiples & Kelly.
    """
    if trades is None or trades.empty:
        print("‚ö† Nenhum trade dispon√≠vel para an√°lise avan√ßada.")
        return

    print("\n===== MONTE CARLO (Equity) =====")
    plot_monte_carlo(trades, initial_capital=initial_capital, n_sims=10000, mode="shuffle")

    print("\n===== MONTE CARLO (Distribui√ß√£o) =====")
    plot_monte_carlo_distribution(trades, initial_capital=initial_capital, n_sims=500, mode="bootstrap")

    print("\n===== ROBUSTEZ EMA (Heatmap) =====")
    # Pode ajustar os ranges se quiser mais/menos granular
    plot_ema_robustness_heatmap(df, config,
                                fast_range=range(5, 15),
                                slow_range=range(15, 35))

    print("\n===== R-MULTIPLES & KELLY =====")
    summarize_r_and_kelly(trades)

    print("\n===== FIM DA AN√ÅLISE AVAN√áADA =====")

advanced_analysis_dashboard(
    df,
    trades,
    CONFIG,
    initial_capital=CONFIG.get("initial_capital", 1000.0)
)

"""#11 - Gerador Html"""

# ============================================================
# GR√ÅFICOS DE OTIMIZA√á√ÉO TEMPORAL (Novas Fun√ß√µes)
# ============================================================
def chart_performance_by_hour(trades):
    tr = trades.copy()
    # Assume que 'entry_time' est√° em UTC ou a coluna j√° tem a info UTC
    tr['hour'] = tr['entry_time'].dt.hour

    # Calcular PnL l√≠quido total por hora
    pnl_by_hour = tr.groupby('hour')['pnl'].sum()

    # Preencher horas sem trades com PnL 0 para plotagem completa (0-23)
    pnl_all_hours = pd.Series(0.0, index=range(24))
    pnl_all_hours.update(pnl_by_hour)

    # Determinar cores
    colors = ['#4ade80' if val > 0 else '#f87171' for val in pnl_all_hours.values]

    fig, ax = plt.subplots(figsize=(18, 5))
    ax.bar(pnl_all_hours.index, pnl_all_hours.values, color=colors)

    ax.set_title("Performance por Hora (UTC)")
    ax.set_xlabel("Hora (UTC)")
    ax.set_ylabel("PnL L√≠quido ($)")
    ax.axhline(0, color='white', linewidth=0.5) # Linha horizontal no zero
    ax.set_xticks(range(0, 24, 4))
    ax.grid(True, axis='y', linestyle='--', alpha=0.5)

    return fig_to_base64(fig)


def chart_performance_by_weekday(trades):
    tr = trades.copy()
    # 0 = Segunda-feira, 6 = Domingo
    tr['weekday'] = tr['entry_time'].dt.dayofweek

    # Mapear n√∫meros para nomes dos dias (necess√°rio para o gr√°fico)
    weekday_map = {0: 'Segunda', 1: 'Ter√ßa', 2: 'Quarta', 3: 'Quinta', 4: 'Sexta', 5: 'S√°bado', 6: 'Domingo'}

    # Calcular PnL l√≠quido total por dia da semana
    pnl_by_weekday = tr.groupby('weekday')['pnl'].sum()

    # Preencher dias sem trades com PnL 0
    pnl_all_days = pd.Series(0.0, index=range(7))
    pnl_all_days.update(pnl_by_weekday)

    # Determinar cores
    colors = ['#4ade80' if val > 0 else '#f87171' for val in pnl_all_days.values]

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.bar(pnl_all_days.index, pnl_all_days.values, color=colors)

    ax.set_title("Performance Semanal")
    ax.set_ylabel("PnL L√≠quido ($)")
    ax.set_xticks(pnl_all_days.index)
    ax.set_xticklabels([weekday_map[i] for i in pnl_all_days.index])
    ax.axhline(0, color='white', linewidth=0.5)
    ax.grid(True, axis='y', linestyle='--', alpha=0.5)

    return fig_to_base64(fig)

# ============================================================
# RELAT√ìRIO HTML PRO ‚Äî DASHBOARD + GR√ÅFICOS + TABELA DE TRADES
# Usando APENAS imagens j√° salvas em disco (PNG)
# ============================================================

import os
import base64
import numpy as np
import pandas as pd


# ----------------- M√âTRICAS B√ÅSICAS -----------------

def _compute_core_metrics(trades, initial_capital):
    """Calcula as m√©tricas principais para o dashboard."""
    df = trades.copy()

    total_trades = len(df)
    wins   = df[df["pnl"] > 0]
    losses = df[df["pnl"] < 0]

    n_wins   = len(wins)
    n_losses = len(losses)

    gross_profit = wins["pnl"].sum()   if n_wins   > 0 else 0.0
    gross_loss   = losses["pnl"].sum() if n_losses > 0 else 0.0
    net_profit   = df["pnl"].sum()
    final_balance = initial_capital + net_profit

    win_rate = (n_wins / total_trades * 100.0) if total_trades > 0 else 0.0
    profit_factor = (gross_profit / abs(gross_loss)) if gross_loss < 0 else np.nan

    # Equity + Max DD
    equity = initial_capital + df["pnl"].cumsum()
    peak   = equity.cummax()
    dd_pct = (equity - peak) / peak * 100.0
    max_dd_pct = dd_pct.min() if len(dd_pct) > 0 else np.nan

    net_return_pct = (final_balance / initial_capital - 1.0) * 100.0

    return {
        "total_trades": int(total_trades),
        "wins": int(n_wins),
        "losses": int(n_losses),
        "net_profit": float(net_profit),
        "final_balance": float(final_balance),
        "win_rate": float(win_rate),
        "profit_factor": float(profit_factor) if not np.isnan(profit_factor) else None,
        "max_dd_pct": float(max_dd_pct) if not np.isnan(max_dd_pct) else None,
        "net_return_pct": float(net_return_pct),
    }


def _fmt_currency(v):
    return f"${v:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")


def _fmt_pct(v, with_sign=True, decimals=2):
    if v is None or np.isnan(v):
        return "-"
    sign = "+" if with_sign and v >= 0 else ""
    return f"{sign}{v:.{decimals}f}%"


# ----------------- IMAGENS ‚Üí BASE64 -----------------

def _img_to_base64(path):
    """L√™ um arquivo de imagem e devolve base64, ou None se n√£o existir."""
    if not path:
        return None
    if not os.path.exists(path):
        print(f"[HTML] ‚ö† Imagem n√£o encontrada: {path}")
        return None
    with open(path, "rb") as f:
        return base64.b64encode(f.read()).decode("ascii")


# ----------------- RELAT√ìRIO HTML -----------------

def generate_html_report_base64(
    df,
    trades,
    CONFIG,
    initial_capital=1000.0,
    output_path="backtest_report.html",
    img_paths=None,
):
    """
    Gera um HTML dark/cyber com:
      - Dashboard de m√©tricas
      - Blocos de gr√°ficos (imagens PNG j√° salvas)
      - Tabela de trades estilizada

    img_paths √© opcional. Se n√£o for passado, usa nomes padr√£o de arquivo:
      equity_total.png, equity_by_year.png, equity_last_3m.png,
      drawdown_mensal.png, dd_curve.png, histograms.png, heatmap_trades.png,
      scatter_relations.png, plot_3d_atr_volume_price.png, monthly_profit.png, etc.
    """

    if trades is None or trades.empty:
        print("‚ö† Sem trades para gerar relat√≥rio HTML.")
        return

    # Nomes padr√£o dos PNG, se n√£o forem informados
    if img_paths is None:
        img_paths = {
            # curvas de equity
            "equity_total":   "equity_total.png",
            "equity_years":   "equity_by_year.png",
            "equity_last_3m": "equity_last_3m.png",

            # drawdowns
            "dd_mensal":      "drawdown_mensal.png",
            "dd_curve":       "dd_curve.png",

            # an√°lises b√°sicas
            "hist":           "histograms.png",
            "heatmap":        "heatmap_trades.png",
            "scatter":        "scatter_relations.png",

            # an√°lise complementar / avan√ßada
            "atr_3d":         "plot_3d_atr_volume_price.png",
            "monthly_profit": "monthly_profit.png",
            "pf_month":       "profit_factor_by_month.png",
            "yearly_profit":  "yearly_profit.png",
            "best_worst":     "best_worst_trades.png",
            "vol_vs_pnl":     "volatility_vs_pnl.png",
            "boxplot_weekday":"boxplot_weekday.png",
            "boxplot_hour":   "boxplot_hour.png",

            # Monte Carlo & robustez
            "mc_equity":      "monte_carlo_equity.png",
            "mc_dist":        "monte_carlo_distribution.png",
            "ema_heatmap":    "ema_robustness_heatmap.png",
            "r_hist":         "r_multiples_hist.png",
        }

    metrics = _compute_core_metrics(trades, initial_capital)

    retorno_liquido_txt = _fmt_pct(metrics["net_return_pct"], with_sign=True, decimals=2)
    capital_final_txt   = _fmt_currency(metrics["final_balance"])
    fator_lucro_txt     = f"{metrics['profit_factor']:.2f}" if metrics["profit_factor"] is not None else "-"
    taxa_acerto_txt     = _fmt_pct(metrics["win_rate"], with_sign=False, decimals=2)
    taxa_acerto_det     = f"{metrics['wins']} Vit√≥rias / {metrics['losses']} Derrotas"
    max_dd_txt          = _fmt_pct(metrics["max_dd_pct"], with_sign=False, decimals=2)

    # ---------- LER TODAS AS IMAGENS EM BASE64 ----------
    equity_total_b64   = _img_to_base64(img_paths.get("equity_total"))
    equity_years_imgs = []
    for fname in os.listdir():
        if fname.startswith("equity_year_") and fname.endswith(".png"):
            b64 = _img_to_base64(fname)
            equity_years_imgs.append((fname, b64))

    equity_last3m_b64  = _img_to_base64(img_paths.get("equity_last_3m") or img_paths.get("equity_last3m"))
    dd_mensal_b64      = _img_to_base64(img_paths.get("dd_mensal"))
    dd_curve_b64       = _img_to_base64(img_paths.get("dd_curve"))
    hist_b64           = _img_to_base64(img_paths.get("hist") or img_paths.get("histograms"))
    heat_b64           = _img_to_base64(img_paths.get("heatmap"))
    scatter_b64        = _img_to_base64(img_paths.get("scatter"))

    atr3d_b64          = _img_to_base64(img_paths.get("atr_3d"))
    monthly_profit_b64 = _img_to_base64(img_paths.get("monthly_profit"))
    pf_month_b64       = _img_to_base64(img_paths.get("pf_month"))
    yearly_profit_b64  = _img_to_base64(img_paths.get("yearly_profit"))
    best_worst_b64     = _img_to_base64(img_paths.get("best_worst"))
    vol_vs_pnl_b64     = _img_to_base64(img_paths.get("vol_vs_pnl"))
    box_wday_b64       = _img_to_base64(img_paths.get("boxplot_weekday"))
    box_hour_b64       = _img_to_base64(img_paths.get("boxplot_hour"))
    mc_equity_b64      = _img_to_base64(img_paths.get("mc_equity"))
    mc_dist_b64        = _img_to_base64(img_paths.get("mc_dist"))
    ema_heat_b64       = _img_to_base64(img_paths.get("ema_heatmap"))
    r_hist_b64         = _img_to_base64(img_paths.get("r_hist"))

    # ---------- MONTAR BLOCOS DE GR√ÅFICOS ----------
    chart_blocks_html = ""

    # --- Performance principal ---
    if equity_total_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Equity Curve ‚Äî Evolu√ß√£o Total do Capital</h3>
            <p>Mostra a evolu√ß√£o completa da equity da estrat√©gia ao longo de todo o per√≠odo testado.</p>
            <img class="chart-img" src="data:image/png;base64,{equity_total_b64}" />
        </div>
        """

    if equity_years_imgs:
        for fname, b64 in equity_years_imgs:
            chart_blocks_html += f"""
            <div class="chart-block">
                <h3>Equity Anual ‚Äî {fname.replace('equity_year_', '').replace('.png', '')}</h3>
                <img class="chart-img" src="data:image/png;base64,{b64}" />
            </div>
            """


    if equity_last3m_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Equity ‚Äî √öltimos 3 Meses</h3>
            <p>Zoom na performance recente da estrat√©gia, focando apenas nas √∫ltimas semanas/meses de execu√ß√£o.</p>
            <img class="chart-img" src="data:image/png;base64,{equity_last3m_b64}" />
        </div>
        """

    # --- Risco / Drawdown ---
    if dd_mensal_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Drawdown Mensal</h3>
            <p>Pior drawdown percentual de cada m√™s, medido em rela√ß√£o ao pico daquele per√≠odo.</p>
            <img class="chart-img" src="data:image/png;base64,{dd_mensal_b64}" />
        </div>
        """

    if dd_curve_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Curva de Drawdown</h3>
            <p>Hist√≥rico cont√≠nuo do drawdown da estrat√©gia, mostrando profundidade e dura√ß√£o das quedas ao longo do tempo.</p>
            <img class="chart-img" src="data:image/png;base64,{dd_curve_b64}" />
        </div>
        """

    # --- Distribui√ß√µes b√°sicas ---
    if hist_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Distribui√ß√µes ‚Äî PnL, R:R e Dura√ß√£o</h3>
            <p>Histogramas com a distribui√ß√£o dos resultados por trade, rela√ß√£o risco-retorno e tempo de perman√™ncia nas opera√ß√µes.</p>
            <img class="chart-img" src="data:image/png;base64,{hist_b64}" />
        </div>
        """

    if heat_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Heatmap por Dia e Hor√°rio</h3>
            <p>Lucro m√©dio por dia da semana e hora do dia, √∫til para encontrar janelas mais lucrativas ou perigosas.</p>
            <img class="chart-img" src="data:image/png;base64,{heat_b64}" />
        </div>
        """

    if scatter_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Rela√ß√µes de Risco e Tempo vs Lucro</h3>
            <p>Gr√°ficos de dispers√£o analisando m√°ximo favor√°vel, m√°ximo adverso, dura√ß√£o dos trades e o PnL de cada opera√ß√£o.</p>
            <img class="chart-img" src="data:image/png;base64,{scatter_b64}" />
        </div>
        """

    # --- Lucro agregado / calend√°rio ---
    if monthly_profit_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Lucro por M√™s</h3>
            <p>Mostra o lucro l√≠quido acumulado em cada m√™s, ajudando a visualizar ciclos de performance.</p>
            <img class="chart-img" src="data:image/png;base64,{monthly_profit_b64}" />
        </div>
        """

    if pf_month_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Profit Factor por M√™s</h3>
            <p>Fator de lucro mensal, √∫til para ver meses consistentes x meses problem√°ticos.</p>
            <img class="chart-img" src="data:image/png;base64,{pf_month_b64}" />
        </div>
        """

    if yearly_profit_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Lucro Total por Ano</h3>
            <p>Resumo anual de lucro/preju√≠zo, excelente para vis√£o macro da estrat√©gia.</p>
            <img class="chart-img" src="data:image/png;base64,{yearly_profit_b64}" />
        </div>
        """

    if best_worst_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Melhores e Piores Trades</h3>
            <p>Ranking dos maiores ganhos e maiores perdas, mostrando se poucos trades carregam o resultado.</p>
            <img class="chart-img" src="data:image/png;base64,{best_worst_b64}" />
        </div>
        """

    # --- Volatilidade / hor√°rio / weekday ---
    if vol_vs_pnl_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Volatilidade √ó Lucro</h3>
            <p>Correla√ß√£o entre amplitude do candle (High-Low) e resultado dos trades, medindo sensibilidade √† volatilidade.</p>
            <img class="chart-img" src="data:image/png;base64,{vol_vs_pnl_b64}" />
        </div>
        """

    if box_wday_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Distribui√ß√£o de PnL por Dia da Semana</h3>
            <p>Boxplot dos resultados por dia da semana, destacando dias mais vol√°teis ou problem√°ticos.</p>
            <img class="chart-img" src="data:image/png;base64,{box_wday_b64}" />
        </div>
        """

    if box_hour_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Distribui√ß√£o de PnL por Hora do Dia</h3>
            <p>Boxplot dos resultados por hor√°rio, √∫til para identificar janelas de mercado mais sens√≠veis √† estrat√©gia.</p>
            <img class="chart-img" src="data:image/png;base64,{box_hour_b64}" />
        </div>
        """

    # --- Regimes de volatilidade / volume ---
    if atr3d_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Scatter 3D ‚Äî Close √ó Volume √ó ATR</h3>
            <p>Visualiza√ß√£o 3D relacionando pre√ßo de fechamento, volume e ATR. Ajuda a entender regimes de volatilidade e liquidez.</p>
            <img class="chart-img" src="data:image/png;base64,{atr3d_b64}" />
        </div>
        """

    # --- Monte Carlo / Robustez / R-Multiples ---
    if mc_equity_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Monte Carlo ‚Äî Curvas de Equity</h3>
            <p>Simula√ß√µes de Monte Carlo da sequ√™ncia de trades, avaliando se o resultado observado pode ser obra do acaso.</p>
            <img class="chart-img" src="data:image/png;base64,{mc_equity_b64}" />
        </div>
        """

    if mc_dist_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Monte Carlo ‚Äî Distribui√ß√µes de Saldo Final e Max DD</h3>
            <p>Distribui√ß√£o do saldo final e do drawdown m√°ximo nas simula√ß√µes, fornecendo vis√£o de risco extremo.</p>
            <img class="chart-img" src="data:image/png;base64,{mc_dist_b64}" />
        </div>
        """

    if ema_heat_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>Mapa de Robustez ‚Äî EMAs</h3>
            <p>Heatmap de lucro por combina√ß√£o de EMA r√°pida x lenta, avaliando qu√£o robustos s√£o os par√¢metros atuais.</p>
            <img class="chart-img" src="data:image/png;base64,{ema_heat_b64}" />
        </div>
        """

    if r_hist_b64:
        chart_blocks_html += f"""
        <div class="chart-block">
            <h3>R-Multiples ‚Äî Distribui√ß√£o</h3>
            <p>Histograma dos R-multiples, medindo a rela√ß√£o risco/retorno por trade e servindo de base para c√°lculo de Kelly.</p>
            <img class="chart-img" src="data:image/png;base64,{r_hist_b64}" />
        </div>
        """

    # ---------- TABELA DE TRADES ----------
    trades_tbl = trades.copy().reset_index(drop=True)
    trades_tbl["id_str"] = "#" + (trades_tbl.index + 1).astype(str)

    if "entry_time" in trades_tbl.columns:
        t = pd.to_datetime(trades_tbl["entry_time"])
    elif "exit_time" in trades_tbl.columns:
        t = pd.to_datetime(trades_tbl["exit_time"])
    else:
        t = pd.to_datetime(trades_tbl.index, unit="D")

    trades_tbl["data"] = t.dt.strftime("%Y-%m-%d")
    trades_tbl["hora"] = t.dt.strftime("%H:%M")

    dias = ["Seg", "Ter", "Qua", "Qui", "Sex", "S√°b", "Dom"]
    trades_tbl["dia_semana"] = t.dt.dayofweek.apply(lambda x: dias[x] if 0 <= x < 7 else "")

    if "direction" in trades_tbl.columns:
        tipo = trades_tbl["direction"].astype(str).str.upper()
    elif "side" in trades_tbl.columns:
        tipo = trades_tbl["side"].astype(str).str.upper()
    elif "signal" in trades_tbl.columns:
        tipo = trades_tbl["signal"].apply(lambda x: "LONG" if x > 0 else ("SHORT" if x < 0 else "FLAT"))
    else:
        tipo = "N/A"
    trades_tbl["tipo_str"] = tipo
    trades_tbl["tipo_class"] = trades_tbl["tipo_str"].apply(
        lambda s: "tipo-long" if s == "LONG" else ("tipo-short" if s == "SHORT" else "tipo-flat")
    )

    trades_tbl["hora_tf"] = t.dt.hour.map(lambda h: f"{int(h)}h")

    if "entry_price" in trades_tbl.columns:
        trades_tbl["preco_str"] = trades_tbl["entry_price"].map(
            lambda v: f"${v:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        )
    else:
        trades_tbl["preco_str"] = "-"

    trades_tbl["pnl_str"] = trades_tbl["pnl"].map(
        lambda v: f"{v:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    )
    trades_tbl["pnl_class"] = trades_tbl["pnl"].apply(
        lambda v: "pnl-pos" if v > 0 else ("pnl-neg" if v < 0 else "pnl-zero")
    )
    trades_tbl["status_icon"] = trades_tbl["pnl"].apply(
        lambda v: "‚úî" if v > 0 else ("‚úñ" if v < 0 else "‚Ä¢")
    )
    trades_tbl["status_class"] = trades_tbl["pnl"].apply(
        lambda v: "status-win" if v > 0 else ("status-loss" if v < 0 else "status-flat")
    )

    rows_html = ""
    for _, row in trades_tbl.iterrows():
        rows_html += f"""
        <tr>
            <td class="col-id">{row['id_str']}</td>
            <td class="col-datetime">
                <div class="dt-main">{row['data']}</div>
                <div class="dt-sub">{row['hora']}</div>
            </td>
            <td>
                <span class="day-pill">{row['dia_semana']}</span>
            </td>
            <td class="col-hour">{row['hora_tf']}</td>
            <td class="col-tipo {row['tipo_class']}">{row['tipo_str']}</td>
            <td class="col-preco">{row['preco_str']}</td>
            <td class="{row['pnl_class']} col-pnl">{row['pnl_str']}</td>
            <td class="{row['status_class']} col-status">{row['status_icon']}</td>
        </tr>
        """

    # ---------- HTML COMPLETO ----------
    html = f"""<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Relat√≥rio de Backtest ‚Äì QuantumCrypto Engine</title>
<style>
body {{
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #050816;
    color: #E5ECF4;
}}
.container {{
    max-width: 1200px;
    margin: 30px auto 60px auto;
    padding: 0 20px;
}}
h1 {{
    text-align: left;
    font-size: 26px;
    margin-bottom: 10px;
    color: #ffffff;
}}
.subtitle {{
    font-size: 13px;
    color: #7f8c8d;
    margin-bottom: 30px;
}}
.dashboard-grid {{
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 18px;
    margin-bottom: 35px;
}}
.card {{
    position: relative;
    padding: 18px 20px;
    border-radius: 14px;
    background: radial-gradient(circle at top left, rgba(255,255,255,0.06), rgba(7,16,40,1));
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02), 0 18px 30px rgba(0,0,0,0.65);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}}
.card-header {{
    font-size: 13px;
    letter-spacing: 0.09em;
    text-transform: uppercase;
    color: #cfd6e6;
    margin-bottom: 4px;
}}
.card-value-main {{
    font-size: 26px;
    font-weight: 700;
    margin-bottom: 8px;
}}
.card-subtext {{
    font-size: 13px;
    color: #8f9bb3;
}}
.chip-icon {{
    position: absolute;
    right: 14px;
    top: 14px;
    width: 34px;
    height: 34px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #ffffff;
    font-size: 16px;
    backdrop-filter: blur(8px);
}}
.card.green {{ border: 1px solid #00c853; }}
.card.green .chip-icon {{ background: rgba(0, 200, 83, 0.25); }}
.card.blue  {{ border: 1px solid #2962ff; }}
.card.blue  .chip-icon {{ background: rgba(41, 98, 255, 0.25); }}
.card.red   {{ border: 1px solid #ff1744; }}
.card.red   .chip-icon {{ background: rgba(255, 23, 68, 0.25); }}
.card.orange{{ border: 1px solid #ffab00; }}
.card.orange .chip-icon {{ background: rgba(255, 171, 0, 0.25); }}

/* SE√á√ÉO DE GR√ÅFICOS */
.charts-section {{
    margin-top: 35px;
    margin-bottom: 30px;
}}
.charts-section h2 {{
    font-size: 20px;
    margin-bottom: 12px;
}}
.chart-block {{
    margin-bottom: 26px;
    padding: 14px 16px 18px 16px;
    border-radius: 14px;
    background: radial-gradient(circle at top left, rgba(40,45,89,0.4), #050b1d);
    box-shadow: 0 14px 30px rgba(0,0,0,0.7);
    border: 1px solid rgba(120, 140, 255, 0.4);
}}
.chart-block h3 {{
    font-size: 15px;
    margin: 0 0 6px 0;
}}
.chart-block p {{
    font-size: 12px;
    color: #95a5b0;
    margin: 0 0 10px 0;
}}
.chart-img {{
    width: 100%;
    max-height: 380px;
    object-fit: contain;
    border-radius: 10px;
    background: #020616;
}}

/* TRADES */
.trades-section {{
    margin-top: 30px;
}}
.trades-header {{
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
}}
.trades-header-title {{
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    color: #e5ecf4;
}}
.trades-header-title span.icon {{
    font-size: 18px;
}}
.trades-count-pill {{
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(90, 108, 255, 0.35), rgba(13, 71, 161, 0.4));
    color: #e3e9ff;
    box-shadow: 0 0 0 1px rgba(120,140,255,0.4);
}}
.trades-card {{
    margin-top: 6px;
    border-radius: 14px;
    background: radial-gradient(circle at top left, rgba(40,45,89,0.45), #050b1d);
    box-shadow: 0 18px 40px rgba(0,0,0,0.85);
    border: 1px solid rgba(120, 140, 255, 0.55);
    overflow: hidden;
}}
.trades-card-header-bar {{
    padding: 8px 16px;
    font-size: 12px;
    color: #9fa8da;
    background: linear-gradient(90deg, #0b1024, #161c3b);
    border-bottom: 1px solid rgba(255,255,255,0.03);
}}
.trades-scroll {{
    max-height: 360px;
    overflow-y: auto;
}}
.trades-scroll::-webkit-scrollbar {{
    width: 8px;
}}
.trades-scroll::-webkit-scrollbar-track {{
    background: #050816;
}}
.trades-scroll::-webkit-scrollbar-thumb {{
    background: linear-gradient(#536dfe, #00e5ff);
    border-radius: 999px;
}}
table.trade-table {{
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    background: transparent;
}}
table.trade-table thead {{
    background: #0b1024;
    position: sticky;
    top: 0;
    z-index: 5;
}}
table.trade-table th {{
    text-align: left;
    padding: 8px 14px;
    font-weight: 500;
    color: #8f9bb3;
    border-bottom: 1px solid rgba(255,255,255,0.06);
}}
table.trade-table tbody tr {{
    border-bottom: 1px solid rgba(255,255,255,0.03);
    transition: background 0.15s ease-out;
}}
table.trade-table tbody tr:nth-child(even) {{
    background: rgba(8,14,36,0.9);
}}
table.trade-table tbody tr:nth-child(odd) {{
    background: rgba(5,9,26,0.9);
}}
table.trade-table tbody tr:hover {{
    background: rgba(81, 126, 255, 0.22);
}}
table.trade-table td {{
    padding: 7px 14px;
    color: #ccd4e3;
    vertical-align: middle;
    white-space: nowrap;
}}
.col-id {{
    color: #7f8c8d;
    font-weight: 500;
}}
.col-datetime .dt-main {{
    font-size: 13px;
}}
.col-datetime .dt-sub {{
    font-size: 11px;
    color: #9da8c5;
}}
.day-pill {{
    display: inline-block;
    padding: 2px 10px;
    border-radius: 999px;
    background: rgba(144,164,174,0.25);
    color: #eceff1;
    font-size: 11px;
}}
.col-hour {{
    color: #ffb300;
    font-weight: 600;
    font-size: 12px;
}}
.col-tipo {{
    font-weight: 600;
    letter-spacing: 0.04em;
}}
.tipo-long  {{ color: #4da3ff; }}
.tipo-short {{ color: #ffca28; }}
.tipo-flat  {{ color: #b0bec5; }}
.col-preco {{ color: #e0e0e0; }}
.col-pnl {{ font-weight: 600; }}
.pnl-pos {{ color: #00e676; }}
.pnl-neg {{ color: #ff5252; }}
.pnl-zero {{ color: #b0bec5; }}
.col-status {{ text-align: center; }}
.status-win {{ color: #00e676; font-size: 16px; }}
.status-loss {{ color: #ff5252; font-size: 16px; }}
.status-flat {{ color: #b0bec5; font-size: 14px; }}
</style>
</head>
<body>
<div class="container">
    <h1>Relat√≥rio de Backtest</h1>
    <div class="subtitle">
        Resultado gerado pelo QuantumCrypto Engine ‚Äî Estrat√©gia: {CONFIG.get("strategy_name", "N/A")}
    </div>

    <!-- DASHBOARD -->
    <div class="dashboard-grid">
        <div class="card green">
            <div class="card-header">RETORNO L√çQUIDO</div>
            <div class="card-value-main">{retorno_liquido_txt}</div>
            <div class="card-subtext">Capital Final: {capital_final_txt}</div>
            <div class="chip-icon">üìà</div>
        </div>

        <div class="card blue">
            <div class="card-header">FATOR DE LUCRO</div>
            <div class="card-value-main">{fator_lucro_txt}</div>
            <div class="card-subtext">Margem apertada. Ideal seria &gt; 1.5</div>
            <div class="chip-icon">‚è≥</div>
        </div>

        <div class="card red">
            <div class="card-header">TAXA DE ACERTO</div>
            <div class="card-value-main">{taxa_acerto_txt}</div>
            <div class="card-subtext">{taxa_acerto_det}</div>
            <div class="chip-icon">üìä</div>
        </div>

        <div class="card orange">
            <div class="card-header">MAX DRAWDOWN</div>
            <div class="card-value-main">{max_dd_txt}</div>
            <div class="card-subtext">Risco t√≠pico de estrat√©gia em cripto.</div>
            <div class="chip-icon">üßØ</div>
        </div>
    </div>

    <!-- VIS√ÉO GR√ÅFICA -->
    <div class="charts-section">
        <h2>Vis√£o Gr√°fica da Estrat√©gia</h2>
        {chart_blocks_html}
    </div>

    <!-- REGISTRO DE TRADES -->
    <div class="trades-section">
        <div class="trades-header">
            <div class="trades-header-title">
                <span class="icon">‚ò∞</span>
                <span>Registro de Trades Enriquecido</span>
            </div>
            <div class="trades-count-pill">{metrics['total_trades']} Trades na Amostra</div>
        </div>

        <div class="trades-card">
            <div class="trades-card-header-bar">
                Hist√≥rico detalhado com data/hora, dire√ß√£o, pre√ßo de entrada e resultado financeiro.
            </div>
            <div class="trades-scroll">
                <table class="trade-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Data/Hora</th>
                            <th>Dia</th>
                            <th>Hora</th>
                            <th>Tipo</th>
                            <th>Pre√ßo Ent.</th>
                            <th>PnL ($)</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        {rows_html}
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>
</body>
</html>
"""

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(html)

    print(f"‚úÖ Relat√≥rio HTML salvo em: {output_path}")

img_paths = {
    "equity_total":   "equity_total.png",
    "equity_years":   None,  # j√° usamos m√∫ltiplos anos via loop
    "equity_last_3m": "equity_last_3m.png",
    "dd_mensal":      "drawdown_mensal.png",
    "dd_curve":       "dd_curve.png",
    "hist":           "histograms.png",
    "heatmap":        "heatmap_trades.png",
    "scatter":        "scatter_relations.png",
    "atr_3d":         "plot_3d_atr_volume_price.png",
    "monthly_profit": "monthly_profit.png",
    "pf_month":       "profit_factor_by_month.png",
    "yearly_profit":  "yearly_profit.png",
    "best_worst":     "best_worst_trades.png",
    "vol_vs_pnl":     "volatility_vs_pnl.png",
    "boxplot_weekday":"boxplot_weekday.png",
    "boxplot_hour":   "boxplot_hour.png",
    "mc_equity":      "monte_carlo_equity.png",
    "mc_dist":        "monte_carlo_distribution.png",
    "ema_heatmap":    "ema_robustness_heatmap.png",
    "r_hist":         "r_multiples_hist.png",
}


# 1) Rodar backtest (gera df, trades)
# 2) Rodar TODAS as fun√ß√µes de plot que salvam PNG
#    (equity, dd, histogramas, 3D, Monte Carlo, etc.)

# 3) Gerar HTML (sem precisar passar img_paths):
generate_html_report_base64(
    df,
    trades,
    CONFIG,
    initial_capital=CONFIG.get("initial_capital", 1000.0),
    output_path="backtest_report.html",
)

